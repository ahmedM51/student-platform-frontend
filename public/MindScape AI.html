<!DOCTYPE html>
<html lang="ar" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindScape AI - Mind Map Tool</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Import Map for Modules -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "lucide-react": "https://esm.sh/lucide-react@0.263.1",
            "firebase/app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
            "firebase/firestore": "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js",
            "firebase/auth": "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js"
        }
    }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #f8f9fa; }
        /* Smooth animation utility */
        .animate-in { animation: fadeIn 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Layout, Plus, Save, Download, Upload, Share2, 
            Trash2, Type, Zap, MessageSquare, X, ChevronRight, 
            MoreHorizontal, ZoomIn, ZoomOut, Maximize, Home 
        } from 'lucide-react';
        import { initializeApp } from 'firebase/app';
        import { 
            getFirestore, collection, addDoc, getDocs, 
            doc, getDoc, updateDoc, deleteDoc, serverTimestamp, 
            query, where, orderBy 
        } from 'firebase/firestore';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'firebase/auth';

        // ==========================================
        // ⚙️ إعدادات التهيئة (يجب تعديلها لتعمل)
        // ==========================================
        
        // 1. ضع إعدادات Firebase الخاصة بك هنا
        // يمكنك الحصول عليها من: Firebase Console -> Project Settings -> General -> Your apps -> SDK setup and configuration
        const firebaseConfig = {
            apiKey: "AIzaSy...",
            authDomain: "your-project.firebaseapp.com",
            projectId: "your-project-id",
            storageBucket: "your-project.appspot.com",
            messagingSenderId: "123456789",
            appId: "1:123456789:web:abcdef"
        };

        // 2. ضع مفتاح Gemini API هنا (للميزات الذكاء الاصطناعي)
        // احصل عليه من: https://aistudio.google.com/app/apikey
        const GEMINI_API_KEY = ""; 

        // ==========================================

        // تهيئة Firebase فقط إذا تم توفير الإعدادات الصحيحة لتجنب توقف التطبيق
        let app, db, auth;
        try {
            // التحقق مما إذا كانت الإعدادات افتراضية (فارغة)
            if (firebaseConfig.apiKey === "AIzaSy...") {
                console.warn("⚠️ تنبيه: لم يتم وضع إعدادات Firebase الحقيقية. الحفظ لن يعمل.");
                // استخدام كائنات وهمية حتى لا ينهار التطبيق عند التشغيل بدون إعدادات
                db = { type: 'dummy' };
                auth = { type: 'dummy' };
            } else {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
            }
        } catch (e) {
            console.error("Firebase init error:", e);
        }

        // --- AI Integration (Gemini) ---
        const generateAIContent = async (prompt, systemInstruction = "") => {
            if (!GEMINI_API_KEY) {
                alert("Please add your Gemini API Key in the code settings.");
                return "";
            }
            try {
                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    systemInstruction: { parts: [{ text: systemInstruction }] },
                };
                
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`, 
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    }
                );

                const data = await response.json();
                if (data.error) throw new Error(data.error.message);
                return data?.candidates?.[0]?.content?.parts?.[0]?.text || "";
            } catch (error) {
                console.error("AI Generation Error:", error);
                alert("AI Error: " + error.message);
                throw error;
            }
        };

        // --- Helper Components ---

        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm p-4">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-md overflow-hidden animate-in">
                        <div className="flex justify-between items-center p-4 border-b">
                            <h3 className="font-bold text-lg text-gray-800">{title}</h3>
                            <button onClick={onClose} className="p-1 hover:bg-gray-100 rounded-full">
                                <X size={20} />
                            </button>
                        </div>
                        <div className="p-4">{children}</div>
                    </div>
                </div>
            );
        };

        const Button = ({ children, onClick, variant = 'primary', className = '', icon: Icon, disabled = false }) => {
            const baseStyle = "flex items-center justify-center gap-2 px-4 py-2 rounded-lg font-medium transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed";
            const variants = {
                primary: "bg-blue-600 text-white hover:bg-blue-700 shadow-md hover:shadow-lg",
                secondary: "bg-white text-gray-700 border border-gray-200 hover:bg-gray-50 hover:border-gray-300 shadow-sm",
                ghost: "text-gray-600 hover:bg-gray-100",
                danger: "bg-red-50 text-red-600 hover:bg-red-100 border border-red-200",
            };

            return (
                <button onClick={onClick} disabled={disabled} className={`${baseStyle} ${variants[variant]} ${className}`}>
                    {Icon && <Icon size={18} />}
                    {children}
                </button>
            );
        };

        // --- Main Application Component ---

        function AmyMindClone() {
            // -- State --
            const [user, setUser] = useState(null);
            const [view, setView] = useState('dashboard'); // dashboard | editor
            const [maps, setMaps] = useState([]);
            const [currentMap, setCurrentMap] = useState(null);
            const [nodes, setNodes] = useState([]);
            const [edges, setEdges] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            
            // Editor UI State
            const [scale, setScale] = useState(1);
            const [offset, setOffset] = useState({ x: 0, y: 0 });
            const [isDraggingCanvas, setIsDraggingCanvas] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [draggingNode, setDraggingNode] = useState(null);
            const [selectedNodeId, setSelectedNodeId] = useState(null);
            
            // AI & Modals
            const [isGenerateModalOpen, setIsGenerateModalOpen] = useState(false);
            const [aiPrompt, setAiPrompt] = useState("");
            const [isChatOpen, setIsChatOpen] = useState(false);
            const [chatMessages, setChatMessages] = useState([]);
            const [chatInput, setChatInput] = useState("");

            const containerRef = useRef(null);

            // -- Auth & Init --
            useEffect(() => {
                if (auth && auth.type !== 'dummy') {
                    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
                        if (currentUser) {
                            setUser(currentUser);
                            fetchMaps(currentUser.uid);
                        } else {
                            signInAnonymously(auth).catch(console.error);
                        }
                    });
                    return () => unsubscribe();
                } else {
                    // وضع المستخدم في وضع عدم الاتصال (للتجربة بدون فايربيس)
                    setUser({ uid: 'offline-user', isAnonymous: true });
                    // تحميل بيانات وهمية للتجربة
                    setMaps([{ id: 'demo', title: 'Demo Map (Offline)', updatedAt: { seconds: Date.now()/1000 } }]);
                }
            }, []);

            // -- Database Operations --
            const fetchMaps = async (userId) => {
                if (db.type === 'dummy') return;
                try {
                    const q = query(
                        collection(db, `users/${userId}/mindmaps`), 
                        orderBy('updatedAt', 'desc')
                    );
                    const querySnapshot = await getDocs(q);
                    const loadedMaps = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    setMaps(loadedMaps);
                } catch (error) {
                    console.error("Error fetching maps:", error);
                }
            };

            const saveMap = async () => {
                if (!user) return;
                
                if (db.type === 'dummy') {
                    alert("Saving is disabled in Demo mode. Please configure Firebase keys in the code.");
                    return;
                }

                setIsLoading(true);
                try {
                    const mapData = {
                        title: currentMap.title,
                        nodes,
                        edges,
                        updatedAt: serverTimestamp()
                    };

                    if (currentMap.id && currentMap.id !== 'demo') {
                        await updateDoc(doc(db, `users/${user.uid}/mindmaps`, currentMap.id), mapData);
                    } else {
                        const docRef = await addDoc(collection(db, `users/${user.uid}/mindmaps`), {
                            ...mapData,
                            createdAt: serverTimestamp()
                        });
                        setCurrentMap(prev => ({ ...prev, id: docRef.id }));
                    }
                    fetchMaps(user.uid);
                } catch (error) {
                    console.error("Error saving map:", error);
                    alert("Error saving: " + error.message);
                } finally {
                    setIsLoading(false);
                }
            };

            const createNewMap = () => {
                const initialNode = { id: 'root', label: 'Central Idea', x: window.innerWidth/2 - 75, y: window.innerHeight/2 - 25, type: 'root' };
                setNodes([initialNode]);
                setEdges([]);
                setCurrentMap({ title: 'Untitled Mind Map' });
                setView('editor');
                setScale(1);
                setOffset({ x: 0, y: 0 });
            };

            const deleteMap = async (mapId, e) => {
                e.stopPropagation();
                if (!confirm("Are you sure you want to delete this map?")) return;
                
                if (db.type === 'dummy') {
                    setMaps(maps.filter(m => m.id !== mapId));
                    return;
                }

                try {
                    await deleteDoc(doc(db, `users/${user.uid}/mindmaps`, mapId));
                    fetchMaps(user.uid);
                } catch (error) {
                    console.error("Error deleting map:", error);
                }
            };

            // -- AI Functions --
            
            const generateMindMapFromText = async () => {
                if (!aiPrompt.trim()) return;
                setIsLoading(true);
                setIsGenerateModalOpen(false);

                try {
                    const systemPrompt = `
                        You are a JSON generator for a mind map application. 
                        Output ONLY valid JSON. No markdown formatting, no code blocks.
                        Structure: { "nodes": [{ "id": "string", "label": "string", "parent": "string (optional)" }], "title": "string" }
                        Root node should not have a parent.
                        Keep labels concise (under 5 words).
                        Generate at least 10 nodes for a comprehensive map.
                    `;
                    
                    const responseText = await generateAIContent(aiPrompt, systemPrompt);
                    if (!responseText) return;

                    // Clean cleanup to ensure valid JSON
                    const jsonStr = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
                    const data = JSON.parse(jsonStr);

                    // Auto-layout algorithm
                    const newNodes = [];
                    const newEdges = [];
                    const rootX = window.innerWidth / 2;
                    const rootY = window.innerHeight / 2;

                    // Process nodes to add coordinates
                    const processedNodes = {};
                    
                    // Find root
                    const rootNode = data.nodes.find(n => !n.parent) || data.nodes[0];
                    newNodes.push({ ...rootNode, x: rootX, y: rootY, type: 'root' });
                    processedNodes[rootNode.id] = { level: 0, index: 0, x: rootX, y: rootY };

                    // Process children recursively-ish or level by level
                    const processChildren = (parentId, level, parentX, parentY, angleRange = { start: 0, end: Math.PI * 2 }) => {
                        const children = data.nodes.filter(n => n.parent === parentId);
                        if (children.length === 0) return;

                        const angleStep = (angleRange.end - angleRange.start) / children.length;
                        const radius = 200 + (level * 50); // Increase radius for outer layers

                        children.forEach((child, index) => {
                            const angle = angleRange.start + (index * angleStep) + (angleStep / 2);
                            // Basic radial layout logic
                            const x = parentX + Math.cos(angle) * radius;
                            const y = parentY + Math.sin(angle) * radius;

                            newNodes.push({ ...child, x, y, type: 'child' });
                            newEdges.push({ id: `e-${parentId}-${child.id}`, source: parentId, target: child.id });

                            // Recurse for grandchildren
                            // Restrict angle for children to avoid overlap (simple heuristic)
                            processChildren(child.id, level + 1, x, y, { 
                                start: angle - angleStep/2, 
                                end: angle + angleStep/2 
                            });
                        });
                    };

                    processChildren(rootNode.id, 0, rootX, rootY);

                    setNodes(newNodes);
                    setEdges(newEdges);
                    setCurrentMap({ ...currentMap, title: data.title || "AI Generated Map" });
                    setAiPrompt("");

                } catch (error) {
                    console.error("AI Parse Error:", error);
                    alert("Failed to generate mind map. Please check API Key or try a simpler prompt.");
                } finally {
                    setIsLoading(false);
                }
            };

            const expandNodeWithAI = async () => {
                if (!selectedNodeId) return;
                const node = nodes.find(n => n.id === selectedNodeId);
                if (!node) return;

                setIsLoading(true);
                try {
                    const systemPrompt = `
                        You are a mind map expander. Given a topic, generate 3-5 sub-topics.
                        Output ONLY valid JSON array of strings: ["Subtopic 1", "Subtopic 2", ...]
                    `;
                    const responseText = await generateAIContent(`Generate sub-topics for: ${node.label}`, systemPrompt);
                    const jsonStr = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
                    const subtopics = JSON.parse(jsonStr);

                    const newNodes = [...nodes];
                    const newEdges = [...edges];
                    
                    subtopics.forEach((label, i) => {
                        const id = `ai-${Date.now()}-${i}`;
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 150;
                        newNodes.push({
                            id,
                            label,
                            x: node.x + Math.cos(angle) * dist,
                            y: node.y + Math.sin(angle) * dist,
                            type: 'child'
                        });
                        newEdges.push({ id: `e-${node.id}-${id}`, source: node.id, target: id });
                    });

                    setNodes(newNodes);
                    setEdges(newEdges);
                } catch (error) {
                    console.error("AI Expansion Error", error);
                } finally {
                    setIsLoading(false);
                }
            };

            const askAIChat = async () => {
                if (!chatInput.trim()) return;
                const userMsg = { role: 'user', text: chatInput };
                setChatMessages(prev => [...prev, userMsg]);
                setChatInput("");
                
                const mapContext = nodes.map(n => n.label).join(", ");
                const systemPrompt = `You are an intelligent assistant for a mind mapping tool. The user is working on a map with these nodes: [${mapContext}]. Answer their questions concisely.`;
                
                try {
                    const response = await generateAIContent(userMsg.text, systemPrompt);
                    setChatMessages(prev => [...prev, { role: 'ai', text: response }]);
                } catch (error) {
                    setChatMessages(prev => [...prev, { role: 'ai', text: "Sorry, I encountered an error." }]);
                }
            };

            // -- Canvas Interactivity --
            
            const screenToCanvas = (sx, sy) => {
                if (!containerRef.current) return { x: 0, y: 0 };
                const rect = containerRef.current.getBoundingClientRect();
                return {
                    x: (sx - rect.left - offset.x) / scale,
                    y: (sy - rect.top - offset.y) / scale
                };
            };

            const handleMouseDown = (e, nodeId = null) => {
                if (nodeId) {
                    setDraggingNode(nodeId);
                    setSelectedNodeId(nodeId);
                } else {
                    setIsDraggingCanvas(true);
                    setDragStart({ x: e.clientX - offset.x, y: e.clientY - offset.y });
                }
            };

            const handleMouseMove = (e) => {
                if (draggingNode) {
                    const pos = screenToCanvas(e.clientX, e.clientY);
                    setNodes(prev => prev.map(n => {
                        if (n.id === draggingNode) {
                            return { ...n, x: n.x + e.movementX / scale, y: n.y + e.movementY / scale };
                        }
                        return n;
                    }));
                } else if (isDraggingCanvas) {
                    setOffset({
                        x: e.clientX - dragStart.x,
                        y: e.clientY - dragStart.y
                    });
                }
            };

            const handleMouseUp = () => {
                setDraggingNode(null);
                setIsDraggingCanvas(false);
            };

            const handleWheel = (e) => {
                e.preventDefault();
                const zoomSensitivity = 0.001;
                const newScale = Math.min(Math.max(0.1, scale - e.deltaY * zoomSensitivity), 5);
                setScale(newScale);
            };

            const addNode = () => {
                if (!selectedNodeId) {
                    alert("Select a parent node first!");
                    return;
                }
                const parent = nodes.find(n => n.id === selectedNodeId);
                const id = `node-${Date.now()}`;
                const newNode = {
                    id,
                    label: "New Node",
                    x: parent.x + 150,
                    y: parent.y + 50,
                    type: 'child'
                };
                setNodes([...nodes, newNode]);
                setEdges([...edges, { id: `e-${parent.id}-${id}`, source: parent.id, target: id }]);
                setSelectedNodeId(id);
            };

            const deleteSelected = () => {
                if (!selectedNodeId) return;
                const nodesToDelete = new Set([selectedNodeId]);
                
                let changed = true;
                while(changed) {
                    changed = false;
                    edges.forEach(e => {
                        if (nodesToDelete.has(e.source) && !nodesToDelete.has(e.target)) {
                            nodesToDelete.add(e.target);
                            changed = true;
                        }
                    });
                }

                setNodes(nodes.filter(n => !nodesToDelete.has(n.id)));
                setEdges(edges.filter(e => !nodesToDelete.has(e.source) && !nodesToDelete.has(e.target)));
                setSelectedNodeId(null);
            };

            const exportMap = (format) => {
                if (format === 'json') {
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify({nodes, edges, title: currentMap.title}));
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", `${currentMap.title}.json`);
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                } else {
                    window.print();
                }
            };

            // --- Views ---

            if (view === 'dashboard') {
                return (
                <div className="min-h-screen bg-slate-50 p-8 font-sans text-slate-900 overflow-auto">
                    <div className="max-w-6xl mx-auto">
                    <header className="flex justify-between items-center mb-12">
                        <div className="flex items-center gap-3">
                        <div className="w-10 h-10 bg-gradient-to-br from-blue-600 to-indigo-600 rounded-xl flex items-center justify-center text-white shadow-lg">
                            <Zap size={24} />
                        </div>
                        <h1 className="text-3xl font-bold tracking-tight text-slate-900">MindScape AI</h1>
                        </div>
                        <div className="flex items-center gap-4">
                        <span className="text-sm text-slate-500 hidden sm:inline">
                            {user ? `User: ${user.uid.slice(0,6)}...` : 'Connecting...'}
                        </span>
                        <Button onClick={createNewMap} icon={Plus}>New Map</Button>
                        </div>
                    </header>

                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <div 
                        onClick={createNewMap}
                        className="group aspect-video border-2 border-dashed border-slate-300 rounded-2xl flex flex-col items-center justify-center cursor-pointer hover:border-blue-500 hover:bg-blue-50/50 transition-all"
                        >
                        <div className="w-12 h-12 bg-white rounded-full shadow-sm flex items-center justify-center text-blue-500 mb-3 group-hover:scale-110 transition-transform">
                            <Plus size={24} />
                        </div>
                        <span className="font-medium text-slate-600">Create from scratch</span>
                        </div>

                        <div 
                        onClick={() => { createNewMap(); setIsGenerateModalOpen(true); }}
                        className="group aspect-video bg-gradient-to-br from-indigo-600 to-purple-700 rounded-2xl p-6 flex flex-col justify-between cursor-pointer shadow-xl hover:shadow-2xl hover:-translate-y-1 transition-all text-white"
                        >
                        <div>
                            <div className="w-10 h-10 bg-white/20 backdrop-blur rounded-lg flex items-center justify-center mb-4">
                            <Zap size={20} />
                            </div>
                            <h3 className="text-xl font-bold mb-1">Generate with AI</h3>
                            <p className="text-indigo-100 text-sm">Turn text or ideas into maps instantly.</p>
                        </div>
                        <div className="flex items-center gap-2 text-sm font-medium opacity-90">
                            Try it now <ChevronRight size={16} />
                        </div>
                        </div>

                        {maps.map(map => (
                        <div key={map.id} 
                            onClick={() => { 
                            setCurrentMap(map); 
                            setNodes(map.nodes || []); 
                            setEdges(map.edges || []); 
                            setView('editor'); 
                            }}
                            className="aspect-video bg-white border border-slate-200 rounded-2xl p-5 flex flex-col justify-between cursor-pointer hover:shadow-lg hover:border-blue-200 transition-all relative group"
                        >
                            <div className="absolute top-4 right-4 opacity-0 group-hover:opacity-100 transition-opacity">
                            <button 
                                onClick={(e) => deleteMap(map.id, e)}
                                className="p-2 hover:bg-red-50 text-slate-400 hover:text-red-500 rounded-lg"
                            >
                                <Trash2 size={16} />
                            </button>
                            </div>
                            <div className="flex-1 flex items-center justify-center opacity-20">
                            <Layout size={48} />
                            </div>
                            <div>
                            <h3 className="font-bold text-lg truncate text-slate-800">{map.title}</h3>
                            <p className="text-xs text-slate-400 mt-1">
                                Updated {map.updatedAt ? (map.updatedAt.seconds ? new Date(map.updatedAt.seconds * 1000).toLocaleDateString() : 'Recently') : 'Just now'}
                            </p>
                            </div>
                        </div>
                        ))}
                    </div>
                    </div>
                </div>
                );
            }

            // Editor View
            return (
                <div className="h-screen w-screen flex flex-col overflow-hidden bg-[#F8F9FA]">
                <header className="h-14 border-b bg-white flex items-center justify-between px-4 z-20 shadow-sm">
                    <div className="flex items-center gap-4">
                    <button onClick={() => setView('dashboard')} className="p-2 hover:bg-slate-100 rounded-lg text-slate-600">
                        <Home size={20} />
                    </button>
                    <div className="h-6 w-px bg-slate-200"></div>
                    <input 
                        value={currentMap?.title || ""} 
                        onChange={(e) => setCurrentMap({...currentMap, title: e.target.value})}
                        className="font-bold text-lg text-slate-800 bg-transparent outline-none focus:bg-slate-50 px-2 rounded"
                        placeholder="Untitled Map"
                    />
                    </div>
                    <div className="flex items-center gap-2">
                    <Button variant="secondary" icon={Download} onClick={() => exportMap('json')} className="hidden sm:flex">Export</Button>
                    <Button variant="secondary" icon={Share2} onClick={() => alert("Shared link copied!")} className="hidden sm:flex">Share</Button>
                    <Button variant="primary" icon={Save} onClick={saveMap}>
                        {isLoading ? "Saving..." : "Save"}
                    </Button>
                    </div>
                </header>

                <div className="flex-1 flex relative overflow-hidden">
                    <div className="w-16 bg-white border-r flex flex-col items-center py-4 gap-4 z-10 shadow-sm">
                    <button 
                        onClick={() => setIsGenerateModalOpen(true)}
                        className="w-10 h-10 rounded-xl bg-indigo-600 text-white flex items-center justify-center shadow hover:bg-indigo-700 transition-colors tooltip"
                        title="AI Generation"
                    >
                        <Zap size={20} />
                    </button>
                    <div className="w-8 h-px bg-slate-200 my-1"></div>
                    <button onClick={addNode} className="p-3 rounded-lg hover:bg-slate-100 text-slate-600" title="Add Node"><Plus size={20} /></button>
                    <button onClick={deleteSelected} className="p-3 rounded-lg hover:bg-red-50 text-slate-600 hover:text-red-500" title="Delete Node"><Trash2 size={20} /></button>
                    <button onClick={() => setScale(1)} className="p-3 rounded-lg hover:bg-slate-100 text-slate-600" title="Reset Zoom"><Maximize size={20} /></button>
                    </div>

                    <div 
                    ref={containerRef}
                    className="flex-1 relative bg-[#f8f9fa] cursor-grab active:cursor-grabbing overflow-hidden"
                    onMouseDown={(e) => handleMouseDown(e)}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp}
                    onWheel={handleWheel}
                    style={{ 
                        backgroundImage: 'radial-gradient(#cbd5e1 1px, transparent 1px)', 
                        backgroundSize: `${20 * scale}px ${20 * scale}px`,
                        backgroundPosition: `${offset.x}px ${offset.y}px`
                    }}
                    >
                    <div style={{ 
                        transform: `translate(${offset.x}px, ${offset.y}px) scale(${scale})`, 
                        transformOrigin: '0 0',
                        position: 'absolute',
                        top: 0, left: 0, width: '100%', height: '100%'
                    }}>
                        <svg className="absolute inset-0 overflow-visible pointer-events-none" style={{ width: '10000px', height: '10000px' }}>
                            {edges.map(edge => {
                            const src = nodes.find(n => n.id === edge.source);
                            const tgt = nodes.find(n => n.id === edge.target);
                            if (!src || !tgt) return null;
                            
                            return (
                                <path 
                                key={edge.id}
                                d={`M ${src.x + 100} ${src.y + 25} C ${src.x + 150} ${src.y + 25}, ${tgt.x - 50} ${tgt.y + 25}, ${tgt.x} ${tgt.y + 25}`}
                                stroke="#cbd5e1" 
                                strokeWidth="3"
                                fill="none"
                                />
                            );
                            })}
                        </svg>

                        {nodes.map(node => {
                            const isSelected = node.id === selectedNodeId;
                            return (
                            <div
                                key={node.id}
                                onMouseDown={(e) => { e.stopPropagation(); handleMouseDown(e, node.id); }}
                                className={`absolute flex items-center justify-center px-6 py-3 rounded-xl shadow-sm border transition-all
                                ${node.type === 'root' 
                                    ? 'bg-indigo-600 text-white border-indigo-700 text-lg font-bold min-w-[150px]' 
                                    : 'bg-white text-slate-700 border-slate-200 font-medium min-w-[120px]'}
                                ${isSelected ? 'ring-2 ring-blue-500 shadow-lg z-10' : 'hover:shadow-md z-0'}
                                `}
                                style={{ 
                                left: node.x, 
                                top: node.y,
                                cursor: 'grab'
                                }}
                            >
                                <input 
                                value={node.label}
                                onChange={(e) => {
                                    setNodes(nodes.map(n => n.id === node.id ? { ...n, label: e.target.value } : n));
                                }}
                                className={`bg-transparent text-center outline-none w-full ${node.type === 'root' ? 'text-white placeholder-indigo-200' : 'text-slate-700'}`}
                                />
                                
                                {isSelected && (
                                <button 
                                    onClick={(e) => { e.stopPropagation(); expandNodeWithAI(); }}
                                    className="absolute -top-3 -right-3 bg-white text-indigo-600 border border-indigo-100 p-1.5 rounded-full shadow-sm hover:scale-110 transition-transform"
                                    title="AI Expand Branch"
                                >
                                    <Zap size={14} fill="currentColor" />
                                </button>
                                )}
                            </div>
                            );
                        })}
                    </div>
                    </div>

                    <button 
                    onClick={() => setIsChatOpen(!isChatOpen)}
                    className="absolute bottom-6 right-6 bg-slate-900 text-white p-4 rounded-full shadow-xl hover:bg-slate-800 transition-colors z-20"
                    >
                    <MessageSquare size={24} />
                    </button>

                    {isChatOpen && (
                    <div className="absolute right-0 top-0 bottom-0 w-80 bg-white shadow-2xl border-l flex flex-col z-30 animate-in">
                        <div className="p-4 border-b flex justify-between items-center bg-slate-50">
                        <h3 className="font-bold flex items-center gap-2"><Zap size={16} className="text-indigo-600"/> AI Assistant</h3>
                        <button onClick={() => setIsChatOpen(false)}><X size={18} /></button>
                        </div>
                        <div className="flex-1 overflow-y-auto p-4 space-y-4">
                        {chatMessages.length === 0 && (
                            <div className="text-center text-slate-400 mt-10 text-sm">
                            Ask me anything about your map,<br/> or ask for ideas!
                            </div>
                        )}
                        {chatMessages.map((msg, i) => (
                            <div key={i} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                            <div className={`max-w-[85%] p-3 rounded-2xl text-sm ${msg.role === 'user' ? 'bg-blue-600 text-white rounded-br-none' : 'bg-slate-100 text-slate-800 rounded-bl-none'}`}>
                                {msg.text}
                            </div>
                            </div>
                        ))}
                        </div>
                        <div className="p-4 border-t">
                        <div className="flex gap-2">
                            <input 
                            value={chatInput}
                            onChange={(e) => setChatInput(e.target.value)}
                            onKeyDown={(e) => e.key === 'Enter' && askAIChat()}
                            placeholder="Ask Amy AI..."
                            className="flex-1 border rounded-lg px-3 py-2 text-sm outline-none focus:border-blue-500"
                            />
                            <Button onClick={askAIChat} variant="primary" className="px-3"><ChevronRight size={18}/></Button>
                        </div>
                        </div>
                    </div>
                    )}
                </div>

                <Modal 
                    isOpen={isGenerateModalOpen} 
                    onClose={() => setIsGenerateModalOpen(false)} 
                    title="Generate Mind Map"
                >
                    <div className="space-y-4">
                    <p className="text-sm text-slate-600">Enter a topic, paste text, or describe what you want to brainstorm.</p>
                    <textarea 
                        value={aiPrompt}
                        onChange={(e) => setAiPrompt(e.target.value)}
                        placeholder="e.g. Marketing strategy for a coffee shop..."
                        className="w-full h-32 border rounded-lg p-3 text-sm outline-none focus:ring-2 ring-indigo-500/20 border-slate-300 resize-none"
                    />
                    <div className="flex justify-end gap-2">
                        <Button variant="ghost" onClick={() => setIsGenerateModalOpen(false)}>Cancel</Button>
                        <Button 
                        variant="primary" 
                        onClick={generateMindMapFromText} 
                        disabled={isLoading || !aiPrompt.trim()}
                        icon={Zap}
                        >
                        {isLoading ? "Generating..." : "Generate Map"}
                        </Button>
                    </div>
                    </div>
                </Modal>

                {isLoading && (
                    <div className="absolute inset-0 bg-white/50 backdrop-blur-sm z-50 flex items-center justify-center flex-col">
                    <div className="w-12 h-12 border-4 border-indigo-600 border-t-transparent rounded-full animate-spin mb-4"></div>
                    <p className="text-indigo-900 font-medium animate-pulse">Thinking...</p>
                    </div>
                )}
                </div>
            );
        }

        // Mount the app
        const root = createRoot(document.getElementById('root'));
        root.render(<AmyMindClone />);
    </script>
</body>
</html>

