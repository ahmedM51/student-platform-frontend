<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindScape AI</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel for JSX & TypeScript in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- Import Map: Cleaned to remove React 19 conflicts -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "lucide-react": "https://esm.sh/lucide-react@0.263.1?deps=react@18.2.0",
    "@google/genai": "https://esm.run/@google/genai",
    "@supabase/supabase-js": "https://esm.sh/@supabase/supabase-js@2",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/"
  }
}
</script>

    <!-- Export helpers: html2canvas (PNG) + jsPDF (PDF) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #f8f9fa; }
        .animate-in { animation: fadeIn 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- Configuration Shim -->
    <script>
        // Set environment variables shim for browser
        window.process = {
            env: {
                // NEW API KEY ADDED HERE
                API_KEY: "AIzaSyBBO9_wsXKC8dn-2v1eVmRIEwKe05BKYGg",
                REACT_APP_SUPABASE_URL: "",
                REACT_APP_SUPABASE_ANON_KEY: ""
            }
        };

        // PDF Worker Setup
        if (window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>

    <!-- Main Application Logic (Consolidated) -->
    <script type="text/babel" data-type="module" data-presets="react,typescript">
        import React, { useState, useEffect, useRef, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Layout, Plus, Save, Download, Upload, Share2, 
            Trash2, Zap, MessageSquare, X, ChevronRight, 
            Maximize, Home 
        } from 'lucide-react';
        import { GoogleGenAI } from "@google/genai";
        import { createClient } from '@supabase/supabase-js';

        // ==========================================
        // 1. SERVICES & LOGIC
        // ==========================================

        // --- AI Service Logic ---
        const apiKey = process.env.API_KEY || '';
        
        // Initialize Gemini
        let aiClient;
        try {
            aiClient = new GoogleGenAI({ apiKey: apiKey || 'DUMMY_KEY' });
        } catch (e) {
            console.error("AI Client Init Error", e);
        }

        const simulateMockResponse = (system, userPrompt) => {
            if (userPrompt.includes("JSON") || (system && system.includes("JSON"))) {
                return `\`\`\`json
                {
                    "title": "Offline Generated Map",
                    "nodes": [
                        { "id": "root", "label": "Main Topic" },
                        { "id": "1", "label": "Branch 1", "parent": "root" },
                        { "id": "2", "label": "Branch 2", "parent": "root" },
                        { "id": "3", "label": "Detail A", "parent": "1" }
                    ]
                }
                \`\`\``;
            }
            if (userPrompt.includes("sub-topics")) {
                return `["Offline Idea 1", "Offline Idea 2", "Offline Idea 3"]`;
            }
            return "Offline mode active. Please check internet or API Key.";
        };

        const generateAIContent = async (prompt, systemInstruction = "") => {
            if (!apiKey || apiKey === 'DUMMY_KEY') {
                console.warn("No API Key provided, using mock response.");
                await new Promise(r => setTimeout(r, 800));
                return simulateMockResponse(systemInstruction, prompt);
            }

            try {
                const response = await aiClient.models.generateContent({
                    model: 'gemini-2.5-flash',
                    contents: prompt,
                    config: { systemInstruction }
                });
                return response.text || "";
            } catch (error) {
                console.error("Gemini API Error:", error);
                return simulateMockResponse(systemInstruction, prompt);
            }
        };

        // --- Supabase Service ---
        const sbUrl = process.env.REACT_APP_SUPABASE_URL;
        const sbKey = process.env.REACT_APP_SUPABASE_ANON_KEY;
        let supabase = null;
        if (sbUrl && sbKey && sbUrl.startsWith('http')) {
            try { supabase = createClient(sbUrl, sbKey); } catch (e) { console.warn("Supabase init error", e); }
        }

        // --- PDF Utils ---
        const readPdfTextFromFile = async (file) => {
            if (!window.pdfjsLib) throw new Error('PDF.js not loaded');
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument(arrayBuffer).promise;
            let fullText = '';
            const maxPages = Math.min(pdf.numPages, 10);
            for (let i = 1; i <= maxPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += pageText + '\n';
            }
            return fullText;
        };

        // ==========================================
        // 2. UI COMPONENTS
        // ==========================================

        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm p-4">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-md overflow-hidden animate-in">
                        <div className="flex justify-between items-center p-4 border-b">
                            <h3 className="font-bold text-lg text-gray-800">{title}</h3>
                            <button onClick={onClose} className="p-1 hover:bg-gray-100 rounded-full">
                                <X size={20} />
                            </button>
                        </div>
                        <div className="p-4">{children}</div>
                    </div>
                </div>
            );
        };

        const Button = ({ children, onClick, variant = 'primary', className = '', icon: Icon, disabled = false }) => {
            const baseStyle = "flex items-center justify-center gap-2 px-4 py-2 rounded-lg font-medium transition-all active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed";
            const variants = {
                primary: "bg-blue-600 text-white hover:bg-blue-700 shadow-md hover:shadow-lg",
                secondary: "bg-white text-gray-700 border border-gray-200 hover:bg-gray-50 hover:border-gray-300 shadow-sm",
                ghost: "text-gray-600 hover:bg-gray-100",
                danger: "bg-red-50 text-red-600 hover:bg-red-100 border border-red-200",
            };

            return (
                <button onClick={onClick} disabled={disabled} className={`${baseStyle} ${variants[variant]} ${className}`}>
                    {Icon && <Icon size={18} />}
                    {children}
                </button>
            );
        };

        // ==========================================
        // 3. MAIN APP COMPONENT
        // ==========================================

        function App() {
            // State
            const [user, setUser] = useState(null);
            const [view, setView] = useState('dashboard');
            const [maps, setMaps] = useState([]);
            const [currentMap, setCurrentMap] = useState(null);
            const [nodes, setNodes] = useState([]);
            const [edges, setEdges] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const [lang, setLang] = useState(localStorage.getItem('lang') || 'ar');
            
            // Editor UI State
            const [scale, setScale] = useState(1);
            const [offset, setOffset] = useState({ x: 0, y: 0 });
            const [isDraggingCanvas, setIsDraggingCanvas] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [draggingNode, setDraggingNode] = useState(null);
            const [selectedNodeId, setSelectedNodeId] = useState(null);
            
            // AI & Chat
            const [isGenerateModalOpen, setIsGenerateModalOpen] = useState(false);
            const [aiPrompt, setAiPrompt] = useState("");
            const [isChatOpen, setIsChatOpen] = useState(false);
            const [chatMessages, setChatMessages] = useState([]);
            const [chatInput, setChatInput] = useState("");

            const containerRef = useRef(null);

            // Localization
            const i18n = {
                ar: {
                    app_title: 'MindScape AI',
                    new_map: 'خريطة جديدة',
                    create_from_scratch: 'إنشاء من الصفر',
                    import_pdf: 'استيراد PDF',
                    generate_with_ai: 'توليد بالذكاء',
                    try_now: 'جرّب الآن',
                    save: 'حفظ',
                    saving: 'جارِ الحفظ...',
                    export_json: 'تصدير',
                    share: 'مشاركة',
                    ai_generation: 'توليد بالذكاء',
                    add_node: 'إضافة عقدة',
                    delete_node: 'حذف العقدة',
                    reset_zoom: 'إعادة التوسيط',
                    ai_chat: 'محادثة الذكاء',
                    map_placeholder: 'خريطة بدون عنوان',
                    pdf: 'PDF',
                    png: 'PNG'
                },
                en: {
                    app_title: 'MindScape AI',
                    new_map: 'New Map',
                    create_from_scratch: 'Create from scratch',
                    import_pdf: 'Import PDF',
                    generate_with_ai: 'Generate with AI',
                    try_now: 'Try it now',
                    save: 'Save',
                    saving: 'Saving...',
                    export_json: 'Export',
                    share: 'Share',
                    ai_generation: 'AI Generation',
                    add_node: 'Add Node',
                    delete_node: 'Delete Node',
                    reset_zoom: 'Reset Zoom',
                    ai_chat: 'AI Chat',
                    map_placeholder: 'Untitled Map',
                    pdf: 'PDF',
                    png: 'PNG'
                }
            };
            const t = (k) => (i18n[lang] && i18n[lang][k]) ? i18n[lang][k] : k;
            
            const setLangAndSave = (l) => { 
                setLang(l); 
                localStorage.setItem('lang', l); 
                try { 
                    document.documentElement.lang = l === 'ar' ? 'ar' : 'en'; 
                    document.documentElement.dir = l === 'ar' ? 'rtl' : 'ltr'; 
                } catch(_){} 
            };

            // Init
            const fetchMaps = useCallback(async (client, userId) => {
                if (!client || userId === 'offline-user') return;
                try {
                    const { data, error } = await client
                        .from('mindmaps')
                        .select('*')
                        .eq('user_id', userId)
                        .order('updated_at', { ascending: false });
                    if (error) throw error;
                    setMaps(data || []);
                } catch (error) {
                    console.error("Error fetching maps:", error);
                }
            }, []);

            const initUser = useCallback(async () => {
                if (!supabase) {
                    setUser({ id: 'offline-user', isOffline: true });
                    setMaps([
                        { 
                            id: 'demo-1', 
                            title: 'Demo Map (Offline)', 
                            nodes: [{id: 'root', label: 'Welcome', x: window.innerWidth/2, y: window.innerHeight/2, type: 'root'}], 
                            edges: [],
                            updated_at: new Date().toISOString()
                        }
                    ]);
                    return;
                }

                const { data: { user: supabaseUser }, error } = await supabase.auth.getUser();
                if (error || !supabaseUser) {
                    setUser({ id: 'offline-user', isOffline: true });
                    setMaps([{ 
                        id: 'demo-1', 
                        title: 'Demo Map (Offline)', 
                        nodes: [{id: 'root', label: 'Start Here', x: window.innerWidth/2, y: window.innerHeight/2, type: 'root'}], 
                        edges: [] 
                    }]);
                } else {
                    setUser({ id: supabaseUser.id, email: supabaseUser.email });
                    await fetchMaps(supabase, supabaseUser.id);
                }
            }, [fetchMaps]);

            useEffect(() => {
                initUser();
                setLangAndSave(lang);
            }, [initUser, lang]);

            // Canvas Handlers
            const handleMouseDown = (e, nodeId = null) => {
                if (nodeId) {
                    setDraggingNode(nodeId);
                    setSelectedNodeId(nodeId);
                } else {
                    setIsDraggingCanvas(true);
                    setDragStart({ x: e.clientX - offset.x, y: e.clientY - offset.y });
                }
            };

            const handleMouseMove = (e) => {
                if (draggingNode) {
                    setNodes(prev => prev.map(n => {
                        if (n.id === draggingNode) {
                            return { ...n, x: n.x + e.movementX / scale, y: n.y + e.movementY / scale };
                        }
                        return n;
                    }));
                } else if (isDraggingCanvas) {
                    setOffset({
                        x: e.clientX - dragStart.x,
                        y: e.clientY - dragStart.y
                    });
                }
            };

            const handleMouseUp = () => {
                setDraggingNode(null);
                setIsDraggingCanvas(false);
            };

            const handleWheel = (e) => {
                e.preventDefault(); 
                const zoomSensitivity = 0.001;
                const newScale = Math.min(Math.max(0.1, scale - e.deltaY * zoomSensitivity), 5);
                setScale(newScale);
            };

            // Actions
            const createNewMap = () => {
                const initialNode = { id: 'root', label: 'Central Idea', x: window.innerWidth/2 - 75, y: window.innerHeight/2 - 25, type: 'root' };
                setNodes([initialNode]);
                setEdges([]);
                setCurrentMap({ title: t('map_placeholder') });
                setView('editor');
                setScale(1);
                setOffset({ x: 0, y: 0 });
            };

            const addNode = () => {
                if (!selectedNodeId) {
                    alert("Select a parent node first!");
                    return;
                }
                const parent = nodes.find(n => n.id === selectedNodeId);
                if (!parent) return;

                const id = `node-${Date.now()}`;
                const newNode = {
                    id,
                    label: "New Node",
                    x: parent.x + 150,
                    y: parent.y + 50,
                    type: 'child',
                    parent: parent.id
                };
                setNodes([...nodes, newNode]);
                setEdges([...edges, { id: `e-${parent.id}-${id}`, source: parent.id, target: id }]);
                setSelectedNodeId(id);
            };

            const deleteSelected = () => {
                if (!selectedNodeId) return;
                const nodesToDelete = new Set([selectedNodeId]);
                let changed = true;
                while(changed) {
                    changed = false;
                    edges.forEach(e => {
                        if (nodesToDelete.has(e.source) && !nodesToDelete.has(e.target)) {
                            nodesToDelete.add(e.target);
                            changed = true;
                        }
                    });
                }
                setNodes(nodes.filter(n => !nodesToDelete.has(n.id)));
                setEdges(edges.filter(e => !nodesToDelete.has(e.source) && !nodesToDelete.has(e.target)));
                setSelectedNodeId(null);
            };

            const saveMap = async () => {
                if (!user) return;
                
                if (user.isOffline || !supabase) {
                    const updated = {
                        ...currentMap,
                        nodes,
                        edges,
                        id: currentMap.id || `local-${Date.now()}`,
                        updated_at: new Date().toISOString()
                    };
                    const existingIdx = maps.findIndex(m => m.id === updated.id);
                    if (existingIdx >= 0) {
                        const newMaps = [...maps];
                        newMaps[existingIdx] = updated;
                        setMaps(newMaps);
                    } else {
                        setMaps([updated, ...maps]);
                    }
                    setCurrentMap(updated);
                    alert("Map saved locally (Offline Mode).");
                    return;
                }

                setIsLoading(true);
                try {
                    const payload = {
                        title: (currentMap && currentMap.title) ? currentMap.title : 'Untitled Mind Map',
                        nodes,
                        edges,
                        user_id: user.id
                    };

                    let savedMap;
                    if (currentMap && currentMap.id) {
                        const { data, error } = await supabase
                            .from('mindmaps')
                            .update(payload)
                            .eq('id', currentMap.id)
                            .eq('user_id', user.id)
                            .select()
                            .single();
                        if (error) throw error;
                        savedMap = data;
                    } else {
                        const { data, error } = await supabase
                            .from('mindmaps')
                            .insert([payload])
                            .select()
                            .single();
                        if (error) throw error;
                        savedMap = data;
                    }

                    if (savedMap) {
                        setCurrentMap(savedMap);
                        fetchMaps(supabase, user.id);
                    }
                } catch (error) {
                    console.error("Error saving map:", error);
                    alert("Error saving: " + error.message); 
                } finally {
                    setIsLoading(false);
                }
            };

            const exportCurrentMap = () => {
                if (!currentMap) {
                    alert('لا توجد خريطة حالية للتصدير');
                    return;
                }

                const exportData = {
                    title: currentMap.title || 'Untitled Mind Map',
                    nodes,
                    edges
                };

                try {
                    const json = JSON.stringify(exportData, null, 2);
                    const blob = new Blob([json], { type: 'application/json' });
                    const safeTitle = (currentMap.title || 'mindmap')
                        .toString()
                        .trim()
                        .replace(/[\\/:*?"<>|]+/g, '_') || 'mindmap';
                    const fileName = safeTitle + '.json';

                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (err) {
                    console.error('Export error:', err);
                    alert('حدث خطأ أثناء التصدير');
                }
            };

            const exportMapAsPNG = async () => {
                try {
                    if (!nodes || nodes.length === 0) {
                        alert('لا توجد عقد في الخريطة للتصدير');
                        return;
                    }

                    // حساب حدود الخريطة من بيانات العقد
                    const padding = 80;
                    const nodeWidths = (node) => node.type === 'root' ? 200 : 160;
                    const nodeHeights = (node) => node.type === 'root' ? 60 : 50;

                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    nodes.forEach(n => {
                        const w = nodeWidths(n);
                        const h = nodeHeights(n);
                        minX = Math.min(minX, n.x);
                        minY = Math.min(minY, n.y);
                        maxX = Math.max(maxX, n.x + w);
                        maxY = Math.max(maxY, n.y + h);
                    });

                    if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) return;

                    const width = (maxX - minX) + padding * 2;
                    const height = (maxY - minY) + padding * 2;

                    const scaleFactor = 2;
                    const canvas = document.createElement('canvas');
                    canvas.width = width * scaleFactor;
                    canvas.height = height * scaleFactor;
                    const ctx = canvas.getContext('2d');
                    if (!ctx) return;

                    ctx.scale(scaleFactor, scaleFactor);

                    // خلفية
                    ctx.fillStyle = '#F8F9FA';
                    ctx.fillRect(0, 0, width, height);

                    // رسم الروابط
                    ctx.strokeStyle = '#cbd5e1';
                    ctx.lineWidth = 2;
                    edges.forEach(edge => {
                        const src = nodes.find(n => n.id === edge.source);
                        const tgt = nodes.find(n => n.id === edge.target);
                        if (!src || !tgt) return;

                        const srcW = nodeWidths(src);
                        const srcH = nodeHeights(src);
                        const tgtW = nodeWidths(tgt);
                        const tgtH = nodeHeights(tgt);

                        const x1 = (src.x - minX) + padding + srcW;
                        const y1 = (src.y - minY) + padding + srcH / 2;
                        const x2 = (tgt.x - minX) + padding;
                        const y2 = (tgt.y - minY) + padding + tgtH / 2;

                        const cp1x = x1 + 50;
                        const cp1y = y1;
                        const cp2x = x2 - 50;
                        const cp2y = y2;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
                        ctx.stroke();
                    });

                    // رسم العقد
                    nodes.forEach(node => {
                        const w = nodeWidths(node);
                        const h = nodeHeights(node);
                        const x = (node.x - minX) + padding;
                        const y = (node.y - minY) + padding;

                        const radius = 16;
                        ctx.beginPath();
                        ctx.moveTo(x + radius, y);
                        ctx.lineTo(x + w - radius, y);
                        ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
                        ctx.lineTo(x + w, y + h - radius);
                        ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
                        ctx.lineTo(x + radius, y + h);
                        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
                        ctx.lineTo(x, y + radius);
                        ctx.quadraticCurveTo(x, y, x + radius, y);
                        ctx.closePath();

                        if (node.type === 'root') {
                            ctx.fillStyle = '#4f46e5';
                        } else {
                            ctx.fillStyle = '#ffffff';
                        }
                        ctx.fill();
                        ctx.strokeStyle = node.type === 'root' ? '#4338ca' : '#e2e8f0';
                        ctx.lineWidth = node.type === 'root' ? 2.5 : 1.5;
                        ctx.stroke();

                        // النص
                        ctx.fillStyle = node.type === 'root' ? '#ffffff' : '#0f172a';
                        ctx.font = (node.type === 'root' ? 'bold 16px system-ui' : '14px system-ui');
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const textX = x + w / 2;
                        const textY = y + h / 2;
                        const label = (node.label || '').toString();
                        ctx.fillText(label, textX, textY);
                    });

                    const dataUrl = canvas.toDataURL('image/png');
                    const safeTitle = (currentMap?.title || 'mindmap')
                        .toString()
                        .trim()
                        .replace(/[\\/:*?"<>|]+/g, '_') || 'mindmap';
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = safeTitle + '.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                } catch (err) {
                    console.error('PNG export error:', err);
                    alert('حدث خطأ أثناء تصدير الصورة');
                }
            };

            const exportMapAsPDF = async () => {
                if (!window.jspdf) return;

                try {
                    if (!nodes || nodes.length === 0) {
                        alert('لا توجد عقد في الخريطة للتصدير');
                        return;
                    }

                    const padding = 80;
                    const nodeWidths = (node) => node.type === 'root' ? 200 : 160;
                    const nodeHeights = (node) => node.type === 'root' ? 60 : 50;

                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    nodes.forEach(n => {
                        const w = nodeWidths(n);
                        const h = nodeHeights(n);
                        minX = Math.min(minX, n.x);
                        minY = Math.min(minY, n.y);
                        maxX = Math.max(maxX, n.x + w);
                        maxY = Math.max(maxY, n.y + h);
                    });

                    if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) return;

                    const width = (maxX - minX) + padding * 2;
                    const height = (maxY - minY) + padding * 2;

                    const scaleFactor = 2;
                    const canvas = document.createElement('canvas');
                    canvas.width = width * scaleFactor;
                    canvas.height = height * scaleFactor;
                    const ctx = canvas.getContext('2d');
                    if (!ctx) return;

                    ctx.scale(scaleFactor, scaleFactor);

                    ctx.fillStyle = '#F8F9FA';
                    ctx.fillRect(0, 0, width, height);

                    ctx.strokeStyle = '#cbd5e1';
                    ctx.lineWidth = 2;
                    edges.forEach(edge => {
                        const src = nodes.find(n => n.id === edge.source);
                        const tgt = nodes.find(n => n.id === edge.target);
                        if (!src || !tgt) return;

                        const srcW = nodeWidths(src);
                        const srcH = nodeHeights(src);
                        const tgtW = nodeWidths(tgt);
                        const tgtH = nodeHeights(tgt);

                        const x1 = (src.x - minX) + padding + srcW;
                        const y1 = (src.y - minY) + padding + srcH / 2;
                        const x2 = (tgt.x - minX) + padding;
                        const y2 = (tgt.y - minY) + padding + tgtH / 2;

                        const cp1x = x1 + 50;
                        const cp1y = y1;
                        const cp2x = x2 - 50;
                        const cp2y = y2;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
                        ctx.stroke();
                    });

                    nodes.forEach(node => {
                        const w = nodeWidths(node);
                        const h = nodeHeights(node);
                        const x = (node.x - minX) + padding;
                        const y = (node.y - minY) + padding;

                        const radius = 16;
                        ctx.beginPath();
                        ctx.moveTo(x + radius, y);
                        ctx.lineTo(x + w - radius, y);
                        ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
                        ctx.lineTo(x + w, y + h - radius);
                        ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
                        ctx.lineTo(x + radius, y + h);
                        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
                        ctx.lineTo(x, y + radius);
                        ctx.quadraticCurveTo(x, y, x + radius, y);
                        ctx.closePath();

                        if (node.type === 'root') {
                            ctx.fillStyle = '#4f46e5';
                        } else {
                            ctx.fillStyle = '#ffffff';
                        }
                        ctx.fill();
                        ctx.strokeStyle = node.type === 'root' ? '#4338ca' : '#e2e8f0';
                        ctx.lineWidth = node.type === 'root' ? 2.5 : 1.5;
                        ctx.stroke();

                        ctx.fillStyle = node.type === 'root' ? '#ffffff' : '#0f172a';
                        ctx.font = (node.type === 'root' ? 'bold 16px system-ui' : '14px system-ui');
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const textX = x + w / 2;
                        const textY = y + h / 2;
                        const label = (node.label || '').toString();
                        ctx.fillText(label, textX, textY);
                    });

                    // استخدم JPEG لتجنب مشاكل تحليل PNG داخل jsPDF
                    const imgData = canvas.toDataURL('image/jpeg', 0.95);
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF('landscape', 'pt', 'a4');

                    const pageWidth = pdf.internal.pageSize.getWidth();
                    const pageHeight = pdf.internal.pageSize.getHeight();
                    const imgWidth = canvas.width;
                    const imgHeight = canvas.height;

                    const ratio = Math.min(pageWidth / imgWidth, pageHeight / imgHeight);
                    const renderWidth = imgWidth * ratio;
                    const renderHeight = imgHeight * ratio;
                    const x = (pageWidth - renderWidth) / 2;
                    const y = (pageHeight - renderHeight) / 2;

                    pdf.addImage(imgData, 'JPEG', x, y, renderWidth, renderHeight);

                    const safeTitle = (currentMap?.title || 'mindmap')
                        .toString()
                        .trim()
                        .replace(/[\\/:*?"<>|]+/g, '_') || 'mindmap';
                    pdf.save(safeTitle + '.pdf');
                } catch (err) {
                    console.error('PDF export error:', err);
                    alert('حدث خطأ أثناء تصدير PDF');
                }
            };

            const deleteMap = async (mapId, e) => {
                e.stopPropagation();
                if (!window.confirm("Are you sure you want to delete this map?")) return;

                if (!user || user.isOffline || !supabase) {
                    setMaps(maps.filter(m => m.id !== mapId));
                    return;
                }

                try {
                    const { error } = await supabase.from('mindmaps').delete().eq('id', mapId).eq('user_id', user.id);
                    if (error) throw error;
                    fetchMaps(supabase, user.id);
                } catch (error) {
                    console.error("Error deleting map:", error);
                }
            };

            const generateMindMapFromText = async () => {
                if (!aiPrompt.trim()) return;
                setIsLoading(true);
                setIsGenerateModalOpen(false);

                try {
                    const systemPrompt = `
                        You are a JSON generator for a mind map application. 
                        Output ONLY valid JSON. No markdown formatting, no code blocks.
                        Structure: { "nodes": [{ "id": "string", "label": "string", "parent": "string (optional)" }], "title": "string" }
                        Root node should not have a parent.
                        Keep labels concise (under 5 words).
                        Generate at least 10 nodes.
                    `;
                    
                    const responseText = await generateAIContent(aiPrompt, systemPrompt);
                    const jsonStr = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
                    const data = JSON.parse(jsonStr);

                    const newNodes = [];
                    const newEdges = [];
                    const rootX = window.innerWidth / 2;
                    const rootY = window.innerHeight / 2;

                    const rootNode = data.nodes.find(n => !n.parent) || data.nodes[0];
                    newNodes.push({ ...rootNode, x: rootX, y: rootY, type: 'root' });

                    const processChildren = (parentId, level, parentX, parentY, angleRange = { start: 0, end: Math.PI * 2 }) => {
                        const children = data.nodes.filter(n => n.parent === parentId);
                        if (children.length === 0) return;

                        const angleStep = (angleRange.end - angleRange.start) / children.length;
                        const radius = 200 + (level * 50);

                        children.forEach((child, index) => {
                            const angle = angleRange.start + (index * angleStep) + (angleStep / 2);
                            const x = parentX + Math.cos(angle) * radius;
                            const y = parentY + Math.sin(angle) * radius;

                            newNodes.push({ ...child, x, y, type: 'child' });
                            newEdges.push({ id: `e-${parentId}-${child.id}`, source: parentId, target: child.id });

                            processChildren(child.id, level + 1, x, y, { 
                                start: angle - angleStep/2, 
                                end: angle + angleStep/2 
                            });
                        });
                    };

                    processChildren(rootNode.id, 0, rootX, rootY);

                    setNodes(newNodes);
                    setEdges(newEdges);
                    setCurrentMap({ ...currentMap, title: data.title || "AI Generated Map" });
                    setAiPrompt("");

                } catch (error) {
                    console.error("AI Error:", error);
                    alert("Failed to generate mind map. AI might be unavailable.");
                } finally {
                    setIsLoading(false);
                }
            };

            const expandNodeWithAI = async () => {
                if (!selectedNodeId) return;
                const node = nodes.find(n => n.id === selectedNodeId);
                if (!node) return;

                setIsLoading(true);
                try {
                    const systemPrompt = `You are a mind map expander. Generate 3-5 sub-topics. Output ONLY JSON array of strings: ["A", "B"]`;
                    const responseText = await generateAIContent(`Generate sub-topics for: ${node.label}`, systemPrompt);
                    const jsonStr = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
                    const subtopics = JSON.parse(jsonStr);

                    const newNodes = [...nodes];
                    const newEdges = [...edges];
                    
                    subtopics.forEach((label, i) => {
                        const id = `ai-${Date.now()}-${i}`;
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 150;
                        newNodes.push({
                            id,
                            label,
                            x: node.x + Math.cos(angle) * dist,
                            y: node.y + Math.sin(angle) * dist,
                            type: 'child',
                            parent: node.id
                        });
                        newEdges.push({ id: `e-${node.id}-${id}`, source: node.id, target: id });
                    });

                    setNodes(newNodes);
                    setEdges(newEdges);
                } catch (error) {
                    console.error("AI Expansion Error", error);
                } finally {
                    setIsLoading(false);
                }
            };

            const askAIChat = async () => {
                if (!chatInput.trim()) return;
                const userMsg = { role: 'user', text: chatInput };
                setChatMessages(prev => [...prev, userMsg]);
                setChatInput("");
                
                const mapContext = nodes.map(n => n.label).join(", ");
                const systemPrompt = `You are an intelligent assistant for a mind mapping tool. Context: [${mapContext}]. Be concise.`;
                
                try {
                    const response = await generateAIContent(userMsg.text, systemPrompt);
                    setChatMessages(prev => [...prev, { role: 'ai', text: response }]);
                } catch (error) {
                    setChatMessages(prev => [...prev, { role: 'ai', text: "Sorry, I encountered an error." }]);
                }
            };

            const handlePdfUpload = async (e) => {
                const file = e.target.files && e.target.files[0];
                if (!file) return;
                setIsLoading(true);
                try {
                    const text = await readPdfTextFromFile(file);
                    setAiPrompt(`Analyze this text and generate a mind map JSON.\n\n${text.substring(0, 20000)}`);
                    setIsGenerateModalOpen(true);
                } catch (err) {
                    console.error('PDF Import Error:', err);
                    alert('PDF Import Error: ' + err.message); 
                } finally {
                    setIsLoading(false);
                    e.target.value = '';
                }
            };

            if (view === 'dashboard') {
                return (
                    <div className="min-h-screen bg-slate-50 p-8 font-sans text-slate-900 overflow-auto">
                        <div className="max-w-6xl mx-auto">
                            <header className="flex flex-wrap justify-between items-center mb-12 gap-4">
                                <div className="flex items-center gap-3">
                                    <div className="w-10 h-10 bg-gradient-to-br from-blue-600 to-indigo-600 rounded-xl flex items-center justify-center text-white shadow-lg">
                                        <Zap size={24} />
                                    </div>
                                    <h1 className="text-3xl font-bold tracking-tight text-slate-900">{t('app_title')}</h1>
                                </div>
                                <div className="flex items-center gap-4">
                                    <span className="text-sm text-slate-500 hidden sm:inline">
                                        {user ? `User: ${user.email || 'Guest'}` : 'Connecting...'}
                                    </span>
                                    <button onClick={() => setLangAndSave(lang==='ar'?'en':'ar')} className="px-3 py-1 rounded border text-slate-700 bg-white hover:bg-slate-50 transition-colors">
                                        {lang==='ar'?'EN':'AR'}
                                    </button>
                                    <Button onClick={createNewMap} icon={Plus}>{t('new_map')}</Button>
                                </div>
                            </header>

                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                <div onClick={createNewMap} className="group aspect-video border-2 border-dashed border-slate-300 rounded-2xl flex flex-col items-center justify-center cursor-pointer hover:border-blue-500 hover:bg-blue-50/50 transition-all">
                                    <div className="w-12 h-12 bg-white rounded-full shadow-sm flex items-center justify-center text-blue-500 mb-3 group-hover:scale-110 transition-transform"><Plus size={24} /></div>
                                    <span className="font-medium text-slate-600">{t('create_from_scratch')}</span>
                                </div>
                                <div onClick={() => { createNewMap(); setIsGenerateModalOpen(true); }} className="group aspect-video bg-gradient-to-br from-indigo-600 to-purple-700 rounded-2xl p-6 flex flex-col justify-between cursor-pointer shadow-xl hover:shadow-2xl hover:-translate-y-1 transition-all text-white">
                                    <div>
                                        <div className="w-10 h-10 bg-white/20 backdrop-blur rounded-lg flex items-center justify-center mb-4"><Zap size={20} /></div>
                                        <h3 className="text-xl font-bold mb-1">{t('generate_with_ai')}</h3>
                                    </div>
                                    <div className="flex items-center gap-2 text-sm font-medium opacity-90">{t('try_now')} <ChevronRight size={16} /></div>
                                </div>
                                {maps.map(map => (
                                    <div key={map.id} onClick={() => { setCurrentMap(map); setNodes(map.nodes || []); setEdges(map.edges || []); setView('editor'); }} className="aspect-video bg-white border border-slate-200 rounded-2xl p-5 flex flex-col justify-between cursor-pointer hover:shadow-lg hover:border-blue-200 transition-all relative group">
                                        <div className="absolute top-4 right-4 opacity-0 group-hover:opacity-100 transition-opacity">
                                            <button onClick={(e) => deleteMap(map.id, e)} className="p-2 hover:bg-red-50 text-slate-400 hover:text-red-500 rounded-lg"><Trash2 size={16} /></button>
                                        </div>
                                        <div className="flex-1 flex items-center justify-center opacity-20"><Layout size={48} /></div>
                                        <div>
                                            <h3 className="font-bold text-lg truncate text-slate-800">{map.title}</h3>
                                            <p className="text-xs text-slate-400 mt-1">{map.updated_at ? new Date(map.updated_at).toLocaleDateString() : 'Recently'}</p>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-screen w-screen flex flex-col overflow-hidden bg-[#F8F9FA]">
                    <header className="h-14 border-b bg-white flex items-center justify-between px-4 z-20 shadow-sm shrink-0">
                        <div className="flex items-center gap-4">
                            <button onClick={() => setView('dashboard')} className="p-2 hover:bg-slate-100 rounded-lg text-slate-600"><Home size={20} /></button>
                            <div className="h-6 w-px bg-slate-200"></div>
                            <input value={currentMap?.title || ""} onChange={(e) => setCurrentMap({...currentMap, title: e.target.value})} className="font-bold text-lg text-slate-800 bg-transparent outline-none focus:bg-slate-50 px-2 rounded" placeholder={t('map_placeholder')} />
                        </div>
                        <div className="flex items-center gap-2">
                            <Button variant="secondary" icon={Download} onClick={exportCurrentMap} className="hidden sm:flex">{t('export_json')}</Button>
                            <Button variant="secondary" onClick={exportMapAsPNG} className="hidden md:flex">{t('png')}</Button>
                            <Button variant="secondary" onClick={exportMapAsPDF} className="hidden md:flex">{t('pdf')}</Button>
                            <Button variant="primary" icon={Save} onClick={saveMap}>{isLoading ? t('saving') : t('save')}</Button>
                        </div>
                    </header>

                    <div className="flex-1 flex relative overflow-hidden">
                        <div className="w-16 bg-white border-r flex flex-col items-center py-4 gap-4 z-10 shadow-sm shrink-0">
                            <button onClick={() => setIsGenerateModalOpen(true)} className="w-10 h-10 rounded-xl bg-indigo-600 text-white flex items-center justify-center shadow hover:bg-indigo-700 transition-colors"><Zap size={20} /></button>
                            <div className="w-8 h-px bg-slate-200 my-1"></div>
                            <button onClick={addNode} className="p-3 rounded-lg hover:bg-slate-100 text-slate-600"><Plus size={20} /></button>
                            <button onClick={deleteSelected} className="p-3 rounded-lg hover:bg-red-50 text-slate-600 hover:text-red-500"><Trash2 size={20} /></button>
                            <label className="p-3 rounded-lg hover:bg-slate-100 text-slate-600 cursor-pointer"><Upload size={20} /><input type="file" accept=".pdf" className="hidden" onChange={handlePdfUpload} /></label>
                            <button onClick={() => { setScale(1); setOffset({x: 0, y: 0}); }} className="p-3 rounded-lg hover:bg-slate-100 text-slate-600"><Maximize size={20} /></button>
                        </div>

                        <div ref={containerRef} className="flex-1 relative bg-[#f8f9fa] cursor-grab active:cursor-grabbing overflow-hidden" onMouseDown={(e) => handleMouseDown(e)} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onWheel={handleWheel} style={{ backgroundImage: 'radial-gradient(#cbd5e1 1px, transparent 1px)', backgroundSize: `${20 * scale}px ${20 * scale}px`, backgroundPosition: `${offset.x}px ${offset.y}px` }}>
                            <div style={{ transform: `translate(${offset.x}px, ${offset.y}px) scale(${scale})`, transformOrigin: '0 0', position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' }}>
                                <svg className="absolute inset-0 overflow-visible pointer-events-none" style={{ width: '10000px', height: '10000px' }}>
                                    {edges.map(edge => {
                                        const src = nodes.find(n => n.id === edge.source);
                                        const tgt = nodes.find(n => n.id === edge.target);
                                        if (!src || !tgt) return null;
                                        return <path key={edge.id} d={`M ${src.x + 100} ${src.y + 25} C ${src.x + 150} ${src.y + 25}, ${tgt.x - 50} ${tgt.y + 25}, ${tgt.x} ${tgt.y + 25}`} stroke="#cbd5e1" strokeWidth="3" fill="none" />;
                                    })}
                                </svg>
                                {nodes.map(node => {
                                    const isSelected = node.id === selectedNodeId;
                                    return (
                                        <div key={node.id} onMouseDown={(e) => { e.stopPropagation(); handleMouseDown(e, node.id); }} className={`absolute flex items-center justify-center px-6 py-3 rounded-xl shadow-sm border transition-all ${node.type === 'root' ? 'bg-indigo-600 text-white border-indigo-700 text-lg font-bold min-w-[150px]' : 'bg-white text-slate-700 border-slate-200 font-medium min-w-[120px]'} ${isSelected ? 'ring-2 ring-blue-500 shadow-lg z-10' : 'hover:shadow-md z-0'}`} style={{ left: node.x, top: node.y, cursor: 'grab' }}>
                                            <input value={node.label} onChange={(e) => { setNodes(nodes.map(n => n.id === node.id ? { ...n, label: e.target.value } : n)); }} className={`bg-transparent text-center outline-none w-full ${node.type === 'root' ? 'text-white placeholder-indigo-200' : 'text-slate-700'}`} />
                                            {isSelected && <button onClick={(e) => { e.stopPropagation(); expandNodeWithAI(); }} className="absolute -top-3 -right-3 bg-white text-indigo-600 border border-indigo-100 p-1.5 rounded-full shadow-sm hover:scale-110 transition-transform"><Zap size={14} fill="currentColor" /></button>}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>

                        <button onClick={() => setIsChatOpen(!isChatOpen)} className="absolute bottom-6 right-6 bg-slate-900 text-white p-4 rounded-full shadow-xl hover:bg-slate-800 transition-colors z-20"><MessageSquare size={24} /></button>
                        
                        {isChatOpen && (
                            <div className="absolute right-0 top-0 bottom-0 w-80 bg-white shadow-2xl border-l flex flex-col z-30 animate-in">
                                <div className="p-4 border-b flex justify-between items-center bg-slate-50"><h3 className="font-bold flex items-center gap-2"><Zap size={16} className="text-indigo-600"/> AI Assistant</h3><button onClick={() => setIsChatOpen(false)}><X size={18} /></button></div>
                                <div className="flex-1 overflow-y-auto p-4 space-y-4">
                                    {chatMessages.length === 0 && <div className="text-center text-slate-400 mt-10 text-sm">Ask me anything about your map,<br/> or ask for ideas!</div>}
                                    {chatMessages.map((msg, i) => <div key={i} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}><div className={`max-w-[85%] p-3 rounded-2xl text-sm ${msg.role === 'user' ? 'bg-blue-600 text-white rounded-br-none' : 'bg-slate-100 text-slate-800 rounded-bl-none'}`}>{msg.text}</div></div>)}
                                </div>
                                <div className="p-4 border-t bg-white"><div className="flex gap-2"><input value={chatInput} onChange={(e) => setChatInput(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && askAIChat()} placeholder="Ask Amy AI..." className="flex-1 border rounded-lg px-3 py-2 text-sm outline-none focus:border-blue-500" /><Button onClick={askAIChat} variant="primary" className="px-3"><ChevronRight size={18}/></Button></div></div>
                            </div>
                        )}
                    </div>

                    <Modal isOpen={isGenerateModalOpen} onClose={() => setIsGenerateModalOpen(false)} title={t('generate_with_ai')}>
                        <div className="space-y-4">
                            <p className="text-sm text-slate-600">Enter a topic, paste text, or describe what you want to brainstorm.</p>
                            <textarea value={aiPrompt} onChange={(e) => setAiPrompt(e.target.value)} placeholder="e.g. Marketing strategy..." className="w-full h-32 border rounded-lg p-3 text-sm outline-none focus:ring-2 ring-indigo-500/20 border-slate-300 resize-none" />
                            <div className="flex justify-end gap-2">
                                <Button variant="ghost" onClick={() => setIsGenerateModalOpen(false)}>Cancel</Button>
                                <Button variant="primary" onClick={generateMindMapFromText} disabled={isLoading || !aiPrompt.trim()} icon={Zap}>{isLoading ? "Thinking..." : "Generate"}</Button>
                            </div>
                        </div>
                    </Modal>

                    {isLoading && <div className="absolute inset-0 bg-white/50 backdrop-blur-sm z-50 flex items-center justify-center flex-col"><div className="w-12 h-12 border-4 border-indigo-600 border-t-transparent rounded-full animate-spin mb-4"></div><p className="text-indigo-900 font-medium animate-pulse">Thinking...</p></div>}
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
