<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MindScape AI - Universal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <style>
        body { 
            font-family: system-ui, -apple-system, sans-serif; 
            overscroll-behavior: none;
        }
        .canvas-bg {
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            touch-action: none;
        }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .animate-fade-in { animation: fadeIn 0.2s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        
        .node {
            position: absolute;
            transition: box-shadow 0.2s, transform 0.1s;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        .node:active { cursor: grabbing; }
        .node.root { background-color: #4f46e5; color: white; border-color: #4338ca; }
        .node.child { background-color: white; color: #334155; border-color: #e2e8f0; }
        .node.selected { box-shadow: 0 0 0 2px #3b82f6, 0 10px 15px -3px rgb(0 0 0 / 0.1); z-index: 10; }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 overflow-hidden h-screen w-screen">

    <div id="app" class="h-full w-full relative">
        <div id="loading-screen" class="absolute inset-0 bg-white flex items-center justify-center z-50">
            <div class="flex flex-col items-center">
                <div class="w-12 h-12 border-4 border-indigo-600 border-t-transparent rounded-full animate-spin mb-4"></div>
                <p class="text-slate-500 font-medium">Loading MindScape AI...</p>
            </div>
        </div>
    </div>

    <input type="file" id="pdf-upload" accept=".pdf" class="hidden" onchange="window.handlePdfUpload(this)">

    <div id="modal-overlay" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
        <div id="modal-content" class="bg-white rounded-xl shadow-2xl w-full max-w-md overflow-hidden animate-fade-in"></div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.0.2/firebase-auth.js';
        import { getFirestore, collection, addDoc, getDocs, doc, updateDoc, deleteDoc, serverTimestamp, query, orderBy } from 'https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js';

        // NEW API KEY INTEGRATED HERE
        const HARDCODED_KEY = "AIzaSyCjNyyRCoDbFM0GwoGQ_v-RBQp0e9l5zlc";

        const state = {
            user: null,
            isOfflineMode: false, 
            view: 'dashboard',
            maps: [],
            currentMap: null,
            nodes: [],
            edges: [],
            scale: 1,
            offset: { x: 0, y: 0 },
            selectedNodeId: null,
            isDraggingCanvas: false,
            isDraggingNode: false,
            dragStart: { x: 0, y: 0 },
            draggedNodeId: null,
            chatOpen: false,
            chatMessages: [],
            // Initialize with hardcoded key to ensure immediate functionality
            apiKey: HARDCODED_KEY,
            lastTouch: { x: 0, y: 0 },
            workingModel: null 
        };

        let db = null;
        let auth = null;

        async function initApp() {
            // Enforce the hardcoded key into storage to overwrite any old/invalid keys
            localStorage.setItem('gemini_api_key', HARDCODED_KEY);
            state.apiKey = HARDCODED_KEY;

            const configStr = typeof __firebase_config !== 'undefined' ? __firebase_config : null;
            if (configStr && configStr !== '""' && configStr !== "{}") {
                try {
                    const firebaseConfig = JSON.parse(configStr);
                    const app = initializeApp(firebaseConfig);
                    auth = getAuth(app);
                    db = getFirestore(app);
                    onAuthStateChanged(auth, async (currentUser) => {
                        if (currentUser) {
                            state.user = currentUser;
                            await fetchMaps();
                            finishLoading();
                        } else {
                            await signInAnonymously(auth);
                        }
                    });
                } catch (e) {
                    enableLocalMode();
                }
            } else {
                enableLocalMode();
            }
        }

        function enableLocalMode() {
            state.isOfflineMode = true;
            if(!localStorage.getItem('local_user_id')) localStorage.setItem('local_user_id', 'local-' + Date.now());
            state.user = { uid: localStorage.getItem('local_user_id'), isAnonymous: true };
            fetchMaps();
            finishLoading();
        }

        function finishLoading() {
            document.getElementById('loading-screen').classList.add('hidden');
            renderApp();
        }

        async function fetchMaps() {
            state.maps = [];
            if (!state.isOfflineMode && db && state.user) {
                try {
                    const q = query(collection(db, `users/${state.user.uid}/mindmaps`), orderBy('updatedAt', 'desc'));
                    const snapshot = await getDocs(q);
                    state.maps = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                } catch (e) { console.error(e); }
            } else {
                const localMaps = JSON.parse(localStorage.getItem(`maps_${state.user.uid}`) || "[]");
                state.maps = localMaps.sort((a,b) => new Date(b.updatedAt) - new Date(a.updatedAt));
            }
        }

        async function saveCurrentMap() {
            if (!state.user || !state.currentMap) return;
            const mapData = {
                title: state.currentMap.title,
                nodes: state.nodes,
                edges: state.edges,
                updatedAt: state.isOfflineMode ? new Date().toISOString() : serverTimestamp()
            };

            if (!state.isOfflineMode && db) {
                if (state.currentMap.id) {
                    await updateDoc(doc(db, `users/${state.user.uid}/mindmaps`, state.currentMap.id), mapData);
                } else {
                    const ref = await addDoc(collection(db, `users/${state.user.uid}/mindmaps`), { ...mapData, createdAt: serverTimestamp() });
                    state.currentMap.id = ref.id;
                }
            } else {
                let maps = JSON.parse(localStorage.getItem(`maps_${state.user.uid}`) || "[]");
                if (state.currentMap.id) {
                    const idx = maps.findIndex(m => m.id === state.currentMap.id);
                    if (idx !== -1) maps[idx] = { ...maps[idx], ...mapData };
                } else {
                    const newId = 'local-map-' + Date.now();
                    state.currentMap.id = newId;
                    maps.push({ id: newId, ...mapData, createdAt: new Date().toISOString() });
                }
                localStorage.setItem(`maps_${state.user.uid}`, JSON.stringify(maps));
            }
            await fetchMaps();
            renderEditor();
            alert("Saved!");
        }

        async function deleteMap(id) {
            if(!confirm("Delete this map?")) return;
            if (!state.isOfflineMode && db) {
                await deleteDoc(doc(db, `users/${state.user.uid}/mindmaps`, id));
            } else {
                let maps = JSON.parse(localStorage.getItem(`maps_${state.user.uid}`) || "[]");
                maps = maps.filter(m => m.id !== id);
                localStorage.setItem(`maps_${state.user.uid}`, JSON.stringify(maps));
            }
            await fetchMaps();
            renderDashboard();
        }

        async function getWorkingModel() {
            if (state.workingModel) return state.workingModel;
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${state.apiKey}`);
                if (response.ok) {
                    const data = await response.json();
                    const models = data.models || [];
                    const genModels = models.filter(m => m.supportedGenerationMethods && m.supportedGenerationMethods.includes("generateContent"));
                    let chosen = genModels.find(m => m.name.includes("flash"));
                    if (!chosen) chosen = genModels.find(m => m.name.includes("pro"));
                    if (!chosen && genModels.length > 0) chosen = genModels[0];
                    if (chosen) {
                        state.workingModel = chosen.name.replace("models/", "");
                        return state.workingModel;
                    }
                }
            } catch (e) {}
            return null; 
        }

        async function generateAI(prompt, systemPrompt) {
            // Ensure key is present
            if(!state.apiKey) state.apiKey = HARDCODED_KEY;

            let modelName = await getWorkingModel();
            const fallbackModels = modelName ? [modelName] : ['gemini-1.5-flash', 'gemini-1.5-flash-latest', 'gemini-pro'];
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] }
            };

            let lastError = null;

            for (const model of fallbackModels) {
                try {
                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${state.apiKey}`, 
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        }
                    );
                    
                    if (!response.ok) {
                        const errText = await response.text();
                        let errorMsg = response.statusText;
                        try { 
                            const json = JSON.parse(errText);
                            errorMsg = json.error.message; 
                        } catch(e){}

                        // Handle Leaked/Invalid Key specifically
                        if (response.status === 403 || (response.status === 400 && errorMsg.includes("key"))) {
                            // Do not delete hardcoded key automatically, just warn
                            window.openSettingsModal();
                            throw new Error("API Key Error. Please check settings.");
                        }

                        if (response.status === 404 || response.status === 429) continue;
                        throw new Error(`${errorMsg} (${response.status})`);
                    }
                    
                    const data = await response.json();
                    state.workingModel = model;
                    return data?.candidates?.[0]?.content?.parts?.[0]?.text || "";

                } catch (e) {
                    lastError = e;
                    if (e.message.includes("Key Error")) throw e; 
                }
            }
            
            throw lastError || new Error("Connection failed. Check Key.");
        }

        async function readPdfText(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            let fullText = "";
            const maxPages = Math.min(pdf.numPages, 10);
            for (let i = 1; i <= maxPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(" ");
                fullText += pageText + "\n";
            }
            return fullText;
        }

        window.triggerPdfUpload = () => document.getElementById('pdf-upload').click();
        
        window.handlePdfUpload = async (input) => {
            if (input.files.length === 0) return;
            const file = input.files[0];
            setLoading(true, `Reading ${file.name}...`);
            try {
                const text = await readPdfText(file);
                if (text.trim().length < 50) throw new Error("Could not extract enough text.");
                setLoading(true, "Analyzing PDF...");
                await handleAIGenerateMap(text, true); 
            } catch (e) {
                alert("PDF Error: " + e.message);
            } finally {
                setLoading(false);
                input.value = ''; 
            }
        };

        async function handleAIGenerateMap(topic, isRaw = false) {
            window.closeModal();
            if(state.view !== 'editor') {
                 state.currentMap = { title: isRaw ? "PDF Map" : topic, id: null };
                 state.nodes = []; state.edges = [];
                 state.view = 'editor';
                 renderApp();
            }

            setLoading(true, "AI is creating map...");
            try {
                let systemPrompt = `You are a JSON generator for mind maps. Output ONLY valid JSON. Structure: { "nodes": [{ "id": "string", "label": "string", "parent": "string (optional)" }], "title": "string" }. Root node no parent. 10+ nodes.`;
                let prompt = topic;
                if (isRaw) {
                    systemPrompt += ` Analyze the raw text provided. Identify the main topic for the root and key sub-concepts.`;
                    prompt = `Analyze this text:\n\n${topic.substring(0, 25000)}`; 
                }

                const res = await generateAI(prompt, systemPrompt);
                const jsonStr = res.replace(/```json/g, '').replace(/```/g, '').trim();
                const data = JSON.parse(jsonStr);
                setupNewMapFromData(data);
                
            } catch (e) {
                alert("AI Error: " + e.message);
            } finally {
                setLoading(false);
            }
        }

        async function handleAIExpandNode() {
            if (!state.selectedNodeId) return;
            const node = state.nodes.find(n => n.id === state.selectedNodeId);
            setLoading(true, "Expanding...");
            try {
                const res = await generateAI("Expand", `Generate 3-5 sub-topics for "${node.label}". Output ONLY valid JSON string array.`);
                const subtopics = JSON.parse(res.replace(/```json/g, '').replace(/```/g, '').trim());
                subtopics.forEach((label, i) => {
                    const id = `ai-${Date.now()}-${i}`;
                    const angle = (Math.random() * Math.PI) + (Math.PI/2);
                    state.nodes.push({ id, label, x: node.x + Math.cos(angle) * 180, y: node.y + Math.sin(angle) * 180, type: 'child' });
                    state.edges.push({ id: `e-${node.id}-${id}`, source: node.id, target: id });
                });
                renderCanvasContent();
            } catch (e) {
                alert("AI Error: " + e.message);
            } finally {
                setLoading(false);
            }
        }

        async function handleAIChat(input) {
            state.chatMessages.push({ role: 'user', text: input });
            renderChatMessages();
            try {
                const context = state.nodes.map(n => n.label).join(", ");
                const res = await generateAI(input, `Assistant for mind map. Context: [${context}]. Concise.`);
                state.chatMessages.push({ role: 'ai', text: res });
            } catch (e) {
                state.chatMessages.push({ role: 'ai', text: `Error: ${e.message}` });
            }
            renderChatMessages();
        }

        function renderChatMessages() {
            const container = document.getElementById('chat-messages');
            if(!container) return;
            container.innerHTML = state.chatMessages.map(msg => `
                <div class="flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}">
                    <div class="max-w-[80%] rounded-lg px-4 py-2 text-sm ${msg.role === 'user' ? 'bg-blue-600 text-white' : 'bg-slate-100 text-slate-800'}">
                        ${msg.text}
                    </div>
                </div>
            `).join('');
            container.scrollTop = container.scrollHeight;
        }

        function setupNewMapFromData(data) {
            const rootX = window.innerWidth/2, rootY = window.innerHeight/2;
            state.nodes = []; state.edges = [];
            const root = data.nodes.find(n => !n.parent) || data.nodes[0];
            state.nodes.push({ ...root, x: rootX, y: rootY, type: 'root' });

            const process = (pid, level, px, py, startA, endA) => {
                const kids = data.nodes.filter(n => n.parent === pid);
                if(!kids.length) return;
                const step = (endA - startA) / kids.length;
                const radius = 180 + (level * 40);
                kids.forEach((k, i) => {
                    const angle = startA + (i * step) + (step/2);
                    const x = px + Math.cos(angle) * radius;
                    const y = py + Math.sin(angle) * radius;
                    state.nodes.push({ ...k, x, y, type: 'child' });
                    state.edges.push({ id: `e-${pid}-${k.id}`, source: pid, target: k.id });
                    process(k.id, level+1, x, y, angle - step/2, angle + step/2);
                });
            };
            process(root.id, 0, rootX, rootY, 0, Math.PI*2);
            state.currentMap.title = data.title || "Map";
            renderApp();
        }

        function createEmptyMap() {
            state.nodes = [{ id: 'root', label: 'Idea', x: window.innerWidth/2 - 75, y: window.innerHeight/2 - 25, type: 'root' }];
            state.edges = [];
            state.currentMap = { title: "Untitled", id: null };
            state.view = 'editor';
            renderApp();
        }

        function renderApp() {
            appEl.innerHTML = '';
            if (state.view === 'dashboard') renderDashboard();
            else renderEditor();
            lucide.createIcons();
        }

        function renderDashboard() {
            const html = `
                <div class="min-h-screen bg-slate-50 p-8 pb-20">
                    <div class="max-w-6xl mx-auto">
                        <header class="flex justify-between items-center mb-12">
                            <h1 class="text-3xl font-bold text-slate-900 flex items-center gap-2"><i data-lucide="zap" class="text-blue-600"></i> MindScape AI</h1>
                            <div class="flex gap-2">
                                <button onclick="window.openSettingsModal()" class="p-2 bg-white rounded-full shadow"><i data-lucide="settings"></i></button>
                                <button onclick="window.triggerCreate()" class="bg-blue-600 text-white px-4 py-2 rounded-lg shadow">New Map</button>
                            </div>
                        </header>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                            <div onclick="window.triggerCreate()" class="cursor-pointer border-2 border-dashed border-slate-300 rounded-2xl p-8 flex flex-col items-center justify-center hover:border-blue-500 bg-white">
                                <i data-lucide="plus" class="text-blue-500 mb-2" size="32"></i>
                                <span>Create New</span>
                            </div>
                            <div onclick="window.triggerPdfUpload()" class="cursor-pointer border-2 border-dashed border-indigo-300 rounded-2xl p-8 flex flex-col items-center justify-center hover:border-indigo-600 bg-indigo-50">
                                <i data-lucide="file-text" class="text-indigo-600 mb-2" size="32"></i>
                                <span>Import PDF</span>
                            </div>
                            <div onclick="window.openAIModal()" class="cursor-pointer bg-gradient-to-br from-indigo-600 to-purple-700 rounded-2xl p-8 text-white flex flex-col items-center justify-center shadow-lg">
                                <i data-lucide="zap" class="mb-2" size="32"></i>
                                <span>Generate with AI</span>
                            </div>
                            ${state.maps.map(m => `
                                <div onclick="window.loadMap('${m.id}')" class="bg-white p-6 rounded-2xl shadow cursor-pointer hover:shadow-md relative group">
                                    <button onclick="event.stopPropagation(); window.deleteMap('${m.id}')" class="absolute top-4 right-4 text-slate-300 hover:text-red-500"><i data-lucide="trash-2" size="16"></i></button>
                                    <h3 class="font-bold text-lg">${m.title}</h3>
                                    <p class="text-xs text-slate-400 mt-2">Last edited recently</p>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>`;
            appEl.innerHTML = html;
        }

        function renderEditor() {
            const html = `
                <div class="flex flex-col h-screen bg-slate-50">
                    <header class="h-14 bg-white border-b flex items-center justify-between px-4 z-20">
                        <div class="flex items-center gap-3">
                            <button onclick="window.goHome()"><i data-lucide="home"></i></button>
                            <input type="text" value="${state.currentMap.title}" onchange="window.updateTitle(this.value)" class="font-bold bg-transparent outline-none w-32">
                        </div>
                        <div class="flex gap-2">
                            <button onclick="window.exportMap()"><i data-lucide="download"></i></button>
                            <button onclick="window.saveCurrentMap()" class="bg-blue-600 text-white px-3 py-1 rounded shadow">Save</button>
                        </div>
                    </header>
                    <div class="flex-1 relative overflow-hidden flex">
                        <div class="w-14 bg-white border-r flex flex-col items-center py-4 gap-4 z-10">
                            <button onclick="window.addNode()"><i data-lucide="plus"></i></button>
                            <button onclick="window.deleteNode()"><i data-lucide="trash-2"></i></button>
                            <button onclick="window.triggerPdfUpload()"><i data-lucide="file-text"></i></button>
                            <button onclick="window.openAIModal()" class="text-indigo-600"><i data-lucide="zap"></i></button>
                        </div>
                        <div id="canvas-container" class="flex-1 relative bg-[#f8f9fa] canvas-bg overflow-hidden">
                            <div id="canvas-content" class="absolute top-0 left-0 w-full h-full origin-top-left">
                                <svg id="edges-layer" class="absolute top-0 left-0 overflow-visible pointer-events-none" style="width:10000px;height:10000px"></svg>
                                <div id="nodes-layer"></div>
                            </div>
                        </div>
                        <button onclick="window.toggleChat()" class="absolute bottom-6 right-6 bg-white p-3 rounded-full shadow-xl z-20"><i data-lucide="message-square"></i></button>
                        <div id="chat-sidebar" class="absolute top-0 right-0 bottom-0 w-80 bg-white shadow-2xl transform transition-transform translate-x-full z-30 flex flex-col">
                            <div class="p-4 border-b flex justify-between"><h3 class="font-bold">AI Chat</h3><button onclick="window.toggleChat()"><i data-lucide="x"></i></button></div>
                            <div id="chat-messages" class="flex-1 overflow-y-auto p-4 space-y-2"></div>
                            <div class="p-4 border-t flex gap-2"><input id="chat-input" class="flex-1 border rounded px-2" placeholder="Ask..."><button onclick="window.sendChat()"><i data-lucide="send"></i></button></div>
                        </div>
                    </div>
                </div>`;
            appEl.innerHTML = html;
            
            const container = document.getElementById('canvas-container');
            const newC = container.cloneNode(true);
            container.parentNode.replaceChild(newC, container);
            
            newC.addEventListener('mousedown', onMouseDown);
            newC.addEventListener('wheel', onWheel);
            newC.addEventListener('touchstart', onTouchStart, {passive:false});
            newC.addEventListener('touchmove', onTouchMove, {passive:false});
            newC.addEventListener('touchend', onTouchEnd);
            
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            
            renderCanvasContent();
            updateCanvasTransform();
        }

        function renderCanvasContent() {
            const el = document.getElementById('edges-layer');
            const nl = document.getElementById('nodes-layer');
            if(!el || !nl) return;
            
            let edges = '';
            state.edges.forEach(e => {
                const s = state.nodes.find(n => n.id === e.source);
                const t = state.nodes.find(n => n.id === e.target);
                if(s && t) {
                    const dx = Math.abs(s.x - t.x);
                    edges += `<path d="M ${s.x+100} ${s.y+25} C ${s.x+150+dx*0.2} ${s.y+25}, ${t.x-50-dx*0.2} ${t.y+25}, ${t.x} ${t.y+25}" stroke="#cbd5e1" stroke-width="2" fill="none" />`;
                }
            });
            el.innerHTML = edges;

            let nodes = '';
            state.nodes.forEach(n => {
                const sel = n.id === state.selectedNodeId;
                nodes += `<div class="node ${n.type} ${sel?'selected':''} flex items-center justify-center px-4 py-2 rounded shadow border bg-white min-w-[100px]" 
                    style="left:${n.x}px;top:${n.y}px" 
                    onmousedown="window.onNodeDown(event,'${n.id}')" 
                    ontouchstart="window.onNodeDown(event,'${n.id}')">
                    <input value="${n.label}" onchange="window.updateNodeLabel('${n.id}',this.value)" class="bg-transparent text-center outline-none w-full" onmousedown="event.stopPropagation()" ontouchstart="event.stopPropagation()">
                    ${sel ? `<button onclick="event.stopPropagation();window.handleAIExpandNode()" ontouchstart="event.stopPropagation();window.handleAIExpandNode()" class="absolute -top-2 -right-2 bg-blue-500 text-white rounded-full p-1"><i data-lucide="zap" size="12"></i></button>`:''}
                </div>`;
            });
            nl.innerHTML = nodes;
            lucide.createIcons();
        }

        function onMouseDown(e) {
            state.isDraggingCanvas = true;
            state.dragStart = { x: e.clientX - state.offset.x, y: e.clientY - state.offset.y };
        }
        function onMouseMove(e) {
            if(state.isDraggingCanvas) {
                state.offset = { x: e.clientX - state.dragStart.x, y: e.clientY - state.dragStart.y };
                updateCanvasTransform();
            } else if(state.isDraggingNode && state.draggedNodeId) {
                const n = state.nodes.find(n => n.id === state.draggedNodeId);
                if(n) { n.x += e.movementX/state.scale; n.y += e.movementY/state.scale; renderCanvasContent(); }
            }
        }
        function onMouseUp() { state.isDraggingCanvas = false; state.isDraggingNode = false; }
        
        function onTouchStart(e) {
            if(e.target.tagName!=='INPUT') e.preventDefault();
            if(e.touches.length===1) {
                state.lastTouch = {x:e.touches[0].clientX, y:e.touches[0].clientY};
                state.isDraggingCanvas = true;
                state.dragStart = { x: state.lastTouch.x - state.offset.x, y: state.lastTouch.y - state.offset.y };
            }
        }
        function onTouchMove(e) {
            if(e.target.tagName!=='INPUT') e.preventDefault();
            if(e.touches.length===1) {
                const t = e.touches[0];
                const dx = t.clientX - state.lastTouch.x;
                const dy = t.clientY - state.lastTouch.y;
                state.lastTouch = {x:t.clientX, y:t.clientY};
                if(state.isDraggingCanvas) {
                    state.offset = { x: t.clientX - state.dragStart.x, y: t.clientY - state.dragStart.y };
                    updateCanvasTransform();
                } else if(state.isDraggingNode) {
                    const n = state.nodes.find(n => n.id === state.draggedNodeId);
                    if(n) { n.x += dx/state.scale; n.y += dy/state.scale; renderCanvasContent(); }
                }
            }
        }
        function onTouchEnd() { state.isDraggingCanvas=false; state.isDraggingNode=false; }
        function onWheel(e) { e.preventDefault(); state.scale = Math.max(0.1, state.scale - e.deltaY*0.001); updateCanvasTransform(); }
        function updateCanvasTransform() {
            const c = document.getElementById('canvas-content');
            const b = document.getElementById('canvas-container');
            if(c) c.style.transform = `translate(${state.offset.x}px,${state.offset.y}px) scale(${state.scale})`;
            if(b) b.style.backgroundPosition = `${state.offset.x}px ${state.offset.y}px`;
        }

        const appEl = document.getElementById('app');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');
        
        window.goHome = () => { state.view='dashboard'; renderApp(); };
        window.triggerCreate = createEmptyMap;
        window.loadMap = (id) => { state.currentMap = state.maps.find(m=>m.id===id); state.nodes=state.currentMap.nodes; state.edges=state.currentMap.edges; state.view='editor'; renderApp(); };
        window.deleteMap = deleteMap;
        window.saveCurrentMap = saveCurrentMap;
        window.exportMap = () => {
            const d = "data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify({nodes:state.nodes, edges:state.edges, title:state.currentMap.title}));
            const a = document.createElement('a'); a.href=d; a.download=`${state.currentMap.title}.json`; a.click();
        };
        window.onNodeDown = (e,id) => {
            e.stopPropagation();
            if(e.type==='touchstart') state.lastTouch = {x:e.touches[0].clientX, y:e.touches[0].clientY};
            state.selectedNodeId=id; state.isDraggingNode=true; state.draggedNodeId=id; state.isDraggingCanvas=false; renderCanvasContent();
        };
        window.updateNodeLabel = (id,v) => { const n=state.nodes.find(x=>x.id===id); if(n) n.label=v; };
        window.updateTitle = (v) => state.currentMap.title=v;
        window.addNode = () => {
            if(!state.selectedNodeId) return alert("Select parent");
            const p = state.nodes.find(n=>n.id===state.selectedNodeId);
            const id = `n-${Date.now()}`;
            state.nodes.push({id, label:"New", x:p.x+100, y:p.y+50, type:'child'});
            state.edges.push({source:p.id, target:id, id:`e-${p.id}-${id}`});
            renderCanvasContent();
        };
        window.deleteNode = () => {
            if(!state.selectedNodeId) return;
            const del = new Set([state.selectedNodeId]);
            let ch = true;
            while(ch) {
                ch=false;
                state.edges.forEach(e => { if(del.has(e.source) && !del.has(e.target)) { del.add(e.target); ch=true; } });
            }
            state.nodes = state.nodes.filter(n=>!del.has(n.id));
            state.edges = state.edges.filter(e=>!del.has(e.source)&&!del.has(e.target));
            state.selectedNodeId=null; renderCanvasContent();
        };
        window.resetView = () => { state.scale=1; state.offset={x:0,y:0}; updateCanvasTransform(); };
        window.toggleChat = () => document.getElementById('chat-sidebar').classList.toggle('translate-x-full');
        window.sendChat = () => { const i=document.getElementById('chat-input'); if(i.value.trim()) { handleAIChat(i.value); i.value=''; } };
        window.handleAIGenerateMap = handleAIGenerateMap;
        window.handleAIExpandNode = handleAIExpandNode;
        
        window.openAIModal = () => {
            modalContent.innerHTML = `
                <div class="p-4 border-b flex justify-between"><h3>Generate Map</h3><button onclick="window.closeModal()"><i data-lucide="x"></i></button></div>
                <div class="p-4"><textarea id="ai-prompt" class="w-full border p-2 h-32 rounded" placeholder="Topic..."></textarea><button onclick="handleAIGenerateMap(document.getElementById('ai-prompt').value)" class="mt-2 bg-blue-600 text-white px-4 py-2 rounded w-full">Generate</button></div>`;
            modalOverlay.classList.remove('hidden');
            lucide.createIcons();
        };
        window.openSettingsModal = () => {
            modalContent.innerHTML = `
                <div class="p-4 border-b flex justify-between"><h3>Settings</h3><button onclick="window.closeModal()"><i data-lucide="x"></i></button></div>
                <div class="p-4">
                    <p class="text-sm mb-2">API Key:</p>
                    <input id="k-input" value="${state.apiKey}" class="w-full border p-2 rounded">
                    <button onclick="window.saveKey()" class="mt-2 bg-blue-600 text-white px-4 py-2 rounded w-full">Save</button>
                    <button onclick="window.resetSettings()" class="mt-2 text-red-500 text-sm underline w-full text-center">Reset Everything</button>
                </div>`;
            modalOverlay.classList.remove('hidden');
            lucide.createIcons();
        };
        window.saveKey = () => { 
            const k = document.getElementById('k-input').value.trim();
            state.apiKey = k; 
            state.workingModel = null; // Reset detected model
            localStorage.setItem('gemini_api_key', k); 
            window.closeModal(); 
            alert("Saved! Retry your action."); 
        };
        window.resetSettings = () => { localStorage.clear(); window.location.reload(); };
        window.closeModal = () => modalOverlay.classList.add('hidden');
        function setLoading(b,t) { 
            const l=document.getElementById('loading-screen'); 
            if(b) { l.classList.remove('hidden'); l.querySelector('p').innerText=t; } else l.classList.add('hidden'); 
        }

        initApp();
    </script>
</body>
</html>


