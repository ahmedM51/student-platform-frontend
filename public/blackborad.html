
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>السبورة الذكية التفاعلية (برو)</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;600;700&display=swap" rel="stylesheet">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel Standalone for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Supabase global client (uses real project config from supabase-config.js) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
    <script src="js/supabase-config.js"></script>
    
    <style>
      body {
        font-family: 'Cairo', sans-serif;
        overscroll-behavior: none;
        user-select: none;
        -webkit-user-select: none;
      }
      /* Prevent pull-to-refresh on mobile */
      html, body {
        overflow: hidden;
        height: 100%;
        width: 100%;
        touch-action: none;
      }
      .no-scrollbar::-webkit-scrollbar {
          display: none;
      }
      .no-scrollbar {
          -ms-overflow-style: none;
          scrollbar-width: none;
      }
      /* Custom cursor styles */
      .cursor-pen { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>') 0 24, crosshair; }
      .cursor-eraser { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="red" stroke-width="2"><path d="M20 20H7L3 16C2 15 2 13 3 12L13 2L22 11L20 20Z"/></svg>') 12 12, cell; }
      
      .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
    </style>

<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "lucide-react": "https://esm.sh/lucide-react@0.263.1",
    "@supabase/supabase-js": "https://esm.sh/@supabase/supabase-js@2",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
<body class="bg-slate-50 text-slate-900">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useEffect, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Pen, Eraser, Type, Square, 
            Highlighter, Move, Wand2, Image as ImageIcon,
            Undo2, Redo2, Download, Trash2, 
            ChevronRight, ChevronLeft, FilePlus,
            Users, Link, Settings, LogOut, Loader2
        } from 'lucide-react';

        // --- 1. UTILS & HELPERS ---

        const generateId = () => Math.random().toString(36).substr(2, 9);

        const drawBackground = (ctx, width, height, type) => {
            ctx.save();
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = '#e2e8f0'; 
            ctx.lineWidth = 1;

            if (type === 'lines') {
                const spacing = 40;
                ctx.beginPath();
                for (let y = spacing; y < height; y += spacing) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                }
                ctx.stroke();
            } else if (type === 'grid') {
                const spacing = 40;
                ctx.beginPath();
                for (let x = spacing; x < width; x += spacing) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                }
                for (let y = spacing; y < height; y += spacing) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                }
                ctx.stroke();
            } else if (type === 'dots') {
                const spacing = 40;
                ctx.fillStyle = '#cbd5e1'; 
                for (let x = spacing; x < width; x += spacing) {
                    for (let y = spacing; y < height; y += spacing) {
                        ctx.beginPath();
                        ctx.arc(x, y, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            ctx.restore();
        };

        const drawShape = (ctx, start, end, type, fill) => {
            const width = end.x - start.x;
            const height = end.y - start.y;
            const centerX = start.x + width / 2;
            const centerY = start.y + height / 2;
            
            ctx.beginPath();
            if (type === 'rectangle') {
                ctx.rect(start.x, start.y, width, height);
            } else if (type === 'circle') {
                ctx.ellipse(centerX, centerY, Math.abs(width) / 2, Math.abs(height) / 2, 0, 0, 2 * Math.PI);
            } else if (type === 'arrow') {
                const angle = Math.atan2(end.y - start.y, end.x - start.x);
                const headLen = 15;
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.moveTo(end.x, end.y);
                ctx.lineTo(end.x - headLen * Math.cos(angle - Math.PI / 6), end.y - headLen * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(end.x, end.y);
                ctx.lineTo(end.x - headLen * Math.cos(angle + Math.PI / 6), end.y - headLen * Math.sin(angle + Math.PI / 6));
            } else if (type === 'star') {
                const spikes = 5;
                const outerRadius = Math.min(Math.abs(width), Math.abs(height)) / 2;
                const innerRadius = outerRadius / 2;
                let rot = Math.PI / 2 * 3;
                let x = centerX;
                let y = centerY;
                const step = Math.PI / spikes;
                ctx.moveTo(centerX, centerY - outerRadius);
                for (let i = 0; i < spikes; i++) {
                    x = centerX + Math.cos(rot) * outerRadius;
                    y = centerY + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                    x = centerX + Math.cos(rot) * innerRadius;
                    y = centerY + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                ctx.lineTo(centerX, centerY - outerRadius);
                ctx.closePath();
            } else if (type === 'check') {
                // Checkmark
                const size = Math.min(Math.abs(width), Math.abs(height));
                const pad = size * 0.2;
                ctx.moveTo(start.x + pad, centerY);
                ctx.lineTo(centerX, end.y - pad);
                ctx.lineTo(end.x - pad, start.y + pad);
            } else if (type === 'cross') {
                // X mark
                const pad = Math.min(Math.abs(width), Math.abs(height)) * 0.2;
                ctx.moveTo(start.x + pad, start.y + pad);
                ctx.lineTo(end.x - pad, end.y - pad);
                ctx.moveTo(end.x - pad, start.y + pad);
                ctx.lineTo(start.x + pad, end.y - pad);
            }

            if (fill && !['arrow', 'check', 'cross'].includes(type)) {
                ctx.fill();
            }
            ctx.stroke();
        };

        // --- 2. COMPONENTS ---

        const SessionModal = ({ isOpen, onClose, onConnect, isConnecting, initialRoomId }) => {
            const [roomId, setRoomId] = useState(initialRoomId || '');
            const [copied, setCopied] = useState(false);

            useEffect(() => {
                if (!roomId) {
                    setRoomId(generateId());
                }
            }, [roomId]);

            if (!isOpen) return null;

            const handleConnect = () => {
                if (!roomId) {
                    alert('من فضلك أدخل كود الجلسة أو استخدم الكود المقترح');
                    return;
                }
                onConnect(roomId);
            };

            const handleCopyLink = async () => {
                try {
                    if (!roomId) return;
                    const url = new URL(window.location.href);
                    url.searchParams.set('room', roomId);
                    await navigator.clipboard.writeText(url.toString());
                    setCopied(true);
                    setTimeout(() => setCopied(false), 2000);
                } catch (e) {
                    alert('تعذر نسخ الرابط، يمكنك نسخه يدويًا من شريط العنوان.');
                }
            };

            return (
                <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center p-4">
                    <div className="bg-white rounded-2xl shadow-2xl w-full max-w-md p-6" dir="rtl">
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-xl font-bold text-gray-800">إعدادات المشاركة الحية</h2>
                            <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
                                <LogOut size={20} />
                            </button>
                        </div>

                        <div className="space-y-4">
                            <div className="bg-blue-50 p-3 rounded-lg text-sm text-blue-700">
                                الجلسات التعاونية تستخدم حساب Supabase الحقيقي الخاص بالمنصة.
                                <br/>
                                فقط أدخل كود الجلسة، ويمكنك مشاركته مع طلابك لينضموا إلى نفس الغرفة.
                            </div>

                            <div className="border-t pt-4 mt-2 space-y-3">
                                <label className="block text-sm font-medium text-gray-700 mb-1">معرف الغرفة (للإنشاء أو الانضمام)</label>
                                <input type="text" value={roomId} onChange={e => setRoomId(e.target.value)} className="w-full border rounded-lg p-2 text-center font-mono tracking-widest" />

                                <div className="flex flex-col sm:flex-row gap-2">
                                    <button 
                                        onClick={handleConnect} 
                                        disabled={isConnecting}
                                        className="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2.5 rounded-xl shadow-lg transition-transform active:scale-95 flex justify-center items-center gap-2"
                                    >
                                        {isConnecting ? <Loader2 className="animate-spin" /> : <Users size={20} />}
                                        بدء / انضمام للجلسة
                                    </button>
                                    <button
                                        type="button"
                                        onClick={handleCopyLink}
                                        className="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-800 font-medium py-2.5 rounded-xl border border-gray-300 text-sm flex items-center justify-center gap-2"
                                    >
                                        <Link size={18} />
                                        {copied ? 'تم نسخ الرابط' : 'نسخ رابط الجلسة'}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const Toolbar = ({ currentTool, setTool, onImageUpload }) => {
            const tools = [
                { id: 'pen', icon: <Pen size={20} />, label: 'قلم' },
                { id: 'highlighter', icon: <Highlighter size={20} />, label: 'تظليل' },
                { id: 'eraser', icon: <Eraser size={20} />, label: 'ممحاة' },
                { id: 'text', icon: <Type size={20} />, label: 'نص' },
                { id: 'shape', icon: <Square size={20} />, label: 'أشكال' },
                { id: 'laser', icon: <Wand2 size={20} />, label: 'ليزر' },
                { id: 'hand', icon: <Move size={20} />, label: 'تحريك' },
            ];

            return (
                <div className="bg-white border-l border-slate-200 shadow-lg flex flex-col items-center py-4 w-16 gap-3 z-20 h-full overflow-y-auto hidden sm:flex no-scrollbar">
                    {tools.map((tool) => (
                        <button
                            key={tool.id}
                            onClick={() => setTool(tool.id)}
                            title={tool.label}
                            className={`p-3 rounded-xl transition-all duration-200 group relative ${
                                currentTool === tool.id 
                                ? 'bg-blue-600 text-white shadow-md scale-105' 
                                : 'text-slate-500 hover:bg-slate-100 hover:text-blue-600'
                            }`}
                        >
                            {tool.icon}
                        </button>
                    ))}
                    <div className="h-px w-10 bg-slate-200 my-1"></div>
                    <label className="p-3 rounded-xl text-slate-500 hover:bg-slate-100 hover:text-green-600 cursor-pointer transition-colors" title="إدراج صورة">
                        <ImageIcon size={20} />
                        <input type="file" accept="image/*" className="hidden" onChange={onImageUpload} />
                    </label>
                </div>
            );
        };

        const MobileToolbar = ({ currentTool, setTool, onImageUpload }) => {
            const tools = [
                { id: 'pen', icon: <Pen size={18} /> },
                { id: 'highlighter', icon: <Highlighter size={18} /> },
                { id: 'eraser', icon: <Eraser size={18} /> },
                { id: 'text', icon: <Type size={18} /> },
                { id: 'shape', icon: <Square size={18} /> },
                { id: 'laser', icon: <Wand2 size={18} /> },
            ];

            return (
                <div className="sm:hidden fixed bottom-0 left-0 right-0 bg-white border-t border-slate-200 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)] flex justify-around p-2 z-50 pb-safe">
                    {tools.map((tool) => (
                        <button
                            key={tool.id}
                            onClick={() => setTool(tool.id)}
                            className={`p-2 rounded-lg transition-colors ${
                                currentTool === tool.id 
                                ? 'bg-blue-100 text-blue-600' 
                                : 'text-slate-500'
                            }`}
                        >
                            {tool.icon}
                        </button>
                    ))}
                    <label className="p-2 rounded-lg text-slate-500 active:bg-slate-100">
                        <ImageIcon size={18} />
                        <input type="file" accept="image/*" className="hidden" onChange={onImageUpload}/>
                    </label>
                </div>
            );
        };

        const COLORS = ['#000000', '#ef4444', '#22c55e', '#3b82f6', '#eab308', '#a855f7'];

        const PropertiesBar = (props) => {
            const { tool, settings, setSettings, shapeType, setShapeType, backgroundType, setBackgroundType, canUndo, canRedo, onUndo, onRedo, onClear, onExport, onSessionClick, isConnected, isTeacher, studentsCanWrite, onToggleStudentsWrite, pageIndex, totalPages, onNextPage, onPrevPage, onNewPage } = props;

            return (
                <div className="bg-white border-b border-slate-200 px-2 sm:px-4 py-2 flex flex-wrap items-center justify-between gap-y-2 z-20 shadow-sm min-h-[60px]">
                    <div className="flex items-center gap-2 sm:gap-4 flex-wrap flex-1">
                        {/* Colors */}
                        {['pen', 'text', 'shape', 'highlighter', 'laser'].includes(tool) && (
                            <div className="flex items-center gap-1">
                                {COLORS.map(c => (
                                    <button
                                        key={c}
                                        onClick={() => setSettings(s => ({ ...s, color: c }))}
                                        className={`w-5 h-5 sm:w-6 sm:h-6 rounded-full border border-slate-200 transition-transform ${
                                            settings.color === c ? 'scale-125 ring-2 ring-offset-1 ring-blue-500' : ''
                                        }`}
                                        style={{ backgroundColor: c }}
                                    />
                                ))}
                                <input 
                                    type="color" 
                                    value={settings.color}
                                    onChange={(e) => setSettings(s => ({ ...s, color: e.target.value }))}
                                    className="w-7 h-7 p-0 border-0 rounded-full overflow-hidden cursor-pointer ml-1"
                                />
                            </div>
                        )}

                        {/* Thickness / Font Size */}
                        {['pen', 'eraser', 'shape', 'highlighter', 'text'].includes(tool) && (
                            <div className="flex items-center gap-2 border-r border-slate-200 pr-2 mr-2">
                                <span className="hidden sm:inline text-xs text-slate-500 font-medium">
                                    {tool === 'text' ? 'حجم الخط' : 'السمك'}
                                </span>
                                <input
                                    type="range"
                                    min="1"
                                    max={tool === 'text' ? 60 : 50}
                                    value={settings.thickness}
                                    onChange={(e) => setSettings(s => ({ ...s, thickness: parseInt(e.target.value) }))}
                                    className="w-16 sm:w-24 h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                                />
                                {tool === 'text' && (
                                    <select
                                        value={settings.thickness}
                                        onChange={(e) => setSettings(s => ({ ...s, thickness: parseInt(e.target.value) }))}
                                        className="bg-slate-50 border border-slate-300 text-slate-900 text-xs rounded-lg p-1 ml-1"
                                    >
                                        <option value={10}>10px</option>
                                        <option value={16}>16px</option>
                                        <option value={24}>24px</option>
                                        <option value={32}>32px</option>
                                        <option value={48}>48px</option>
                                        {!([10, 16, 24, 32, 48].includes(settings.thickness)) && <option value={settings.thickness} disabled hidden>مخصص</option>}
                                    </select>
                                )}
                            </div>
                        )}

                        {tool === 'shape' && (
                            <div className="flex items-center gap-1 border-r border-slate-200 pr-2 mr-2">
                                <select 
                                    value={shapeType}
                                    onChange={(e) => setShapeType(e.target.value)}
                                    className="bg-slate-50 border border-slate-300 text-slate-900 text-sm rounded-lg p-1.5"
                                >
                                    <option value="rectangle">مستطيل</option>
                                    <option value="circle">دائرة</option>
                                    <option value="arrow">سهم</option>
                                    <option value="star">نجمة</option>
                                    <option value="check">صح</option>
                                    <option value="cross">خطأ</option>
                                </select>
                                <label className="flex items-center gap-1 text-sm text-slate-600 cursor-pointer select-none">
                                    <input 
                                        type="checkbox" 
                                        checked={settings.isFilled} 
                                        onChange={(e) => setSettings(s => ({...s, isFilled: e.target.checked}))}
                                        className="w-4 h-4 text-blue-600 rounded"
                                    />
                                    <span className="hidden sm:inline">تعبئة</span>
                                </label>
                            </div>
                        )}
                        
                        {/* Background Selector */}
                        <div className="hidden md:flex items-center gap-2 border-r border-slate-200 pr-2 mr-2">
                           <select 
                              value={backgroundType}
                              onChange={(e) => setBackgroundType(e.target.value)}
                              className="bg-slate-50 border border-slate-300 text-slate-700 text-xs rounded-lg p-1.5"
                            >
                              <option value="plain">خلفية بيضاء</option>
                              <option value="grid">شبكة</option>
                              <option value="lines">تسطير</option>
                              <option value="dots">منقطة</option>
                            </select>
                        </div>
                    </div>

                    {/* Pages Control */}
                    <div className="flex items-center gap-2 bg-slate-100 rounded-lg p-1 mx-2">
                        <button onClick={onPrevPage} disabled={pageIndex === 0} className="p-1 hover:bg-white rounded disabled:opacity-30">
                          <ChevronRight size={18} />
                        </button>
                        <span className="text-xs font-bold text-slate-600 min-w-[3rem] text-center" dir="ltr">
                          {pageIndex + 1} / {totalPages}
                        </span>
                        <button onClick={onNextPage} disabled={pageIndex === totalPages - 1} className="p-1 hover:bg-white rounded disabled:opacity-30">
                          <ChevronLeft size={18} />
                        </button>
                        <div className="w-px h-4 bg-slate-300 mx-1"></div>
                        <button onClick={onNewPage} title="صفحة جديدة" className="p-1 hover:bg-white rounded text-blue-600">
                          <FilePlus size={18} />
                        </button>
                    </div>

                    {/* Right Actions */}
                    <div className="flex items-center gap-2">
                         {/* Session Button */}
                        <button 
                            onClick={onSessionClick}
                            className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-sm font-medium transition-colors ${
                                isConnected 
                                ? 'bg-green-100 text-green-700 border border-green-200' 
                                : 'bg-slate-100 text-slate-700 hover:bg-slate-200'
                            }`}
                        >
                            <Users size={16} />
                            <span className="hidden sm:inline">{isConnected ? 'متصل' : 'جلسة'}</span>
                        </button>

                        {isTeacher && (
                            <button
                                onClick={onToggleStudentsWrite}
                                className={`hidden md:flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-medium border transition-colors ${
                                    studentsCanWrite
                                        ? 'bg-emerald-50 text-emerald-700 border-emerald-200'
                                        : 'bg-amber-50 text-amber-700 border-amber-200'
                                }`}
                                title="التحكم في سماح الطلاب بالكتابة"
                            >
                                {studentsCanWrite ? 'الطلاب يمكنهم الكتابة' : 'الطلاب للعرض فقط'}
                            </button>
                        )}

                        <button onClick={onUndo} disabled={!canUndo} className="p-2 text-slate-600 hover:bg-slate-100 rounded-lg disabled:opacity-30">
                            <Undo2 size={20} />
                        </button>
                        <button onClick={onRedo} disabled={!canRedo} className="p-2 text-slate-600 hover:bg-slate-100 rounded-lg disabled:opacity-30">
                            <Redo2 size={20} />
                        </button>
                        <button onClick={onClear} className="p-2 text-red-500 hover:bg-red-50 rounded-lg">
                            <Trash2 size={20} />
                        </button>
                        <button onClick={onExport} className="p-2 text-purple-600 hover:bg-purple-50 rounded-lg">
                            <Download size={20} />
                        </button>
                    </div>
                </div>
            );
        };

        const Whiteboard = ({
            tool,
            settings,
            shapeType,
            backgroundType,
            onSaveStep,
            snapshot,
            backgroundImage,
            channelRef,
            isConnected,
            canWrite
        }) => {
            const containerRef = useRef(null);
            const canvasRef = useRef(null);
            const tempCanvasRef = useRef(null);
            const [isDrawing, setIsDrawing] = useState(false);
            const [startPoint, setStartPoint] = useState(null);
            const [lastPoint, setLastPoint] = useState(null);
            const [textInput, setTextInput] = useState(null);
            const textAreaRef = useRef(null);
            
            // Laser
            const laserPoints = useRef([]);
            const laserReqRef = useRef(0);
            
            // Remote Cursors (Visual only)
            const [remoteCursors, setRemoteCursors] = useState({});

            const redrawMainCanvas = useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                // Clear
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                drawBackground(ctx, canvas.width, canvas.height, backgroundType);

                if (backgroundImage) {
                    const ratio = Math.min(canvas.width / backgroundImage.width, canvas.height / backgroundImage.height);
                    const cx = (canvas.width - backgroundImage.width * ratio) / 2;
                    const cy = (canvas.height - backgroundImage.height * ratio) / 2;
                    ctx.drawImage(backgroundImage, 0, 0, backgroundImage.width, backgroundImage.height, cx, cy, backgroundImage.width * ratio, backgroundImage.height * ratio);
                }

                if (snapshot) {
                    const img = new Image();
                    img.src = snapshot;
                    img.onload = () => ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                }
            }, [backgroundType, backgroundImage, snapshot]);

            const initCanvas = useCallback(() => {
                if (!containerRef.current || !canvasRef.current || !tempCanvasRef.current) return;
                const { clientWidth, clientHeight } = containerRef.current;
                
                const setDims = (c) => {
                    c.width = clientWidth;
                    c.height = clientHeight;
                };

                setDims(canvasRef.current);
                setDims(tempCanvasRef.current);
                redrawMainCanvas();
            }, [redrawMainCanvas]);

            useEffect(() => {
                window.addEventListener('resize', initCanvas);
                initCanvas();
                return () => window.removeEventListener('resize', initCanvas);
            }, [initCanvas]);

            useEffect(() => {
                redrawMainCanvas();
            }, [redrawMainCanvas]);

            // Handle Remote Strokes
            useEffect(() => {
                if(!isConnected || !channelRef.current) return;
                
                function handleBroadcast(payload) {
                    const canvas = canvasRef.current;
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    const w = canvas.width;
                    const h = canvas.height;

                    if (payload.type === 'draw') {
                        ctx.beginPath();
                        ctx.strokeStyle = payload.color;
                        ctx.lineWidth = payload.thickness;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.globalAlpha = payload.opacity || 1;
                        if(payload.tool === 'eraser') ctx.strokeStyle = '#fff'; 
                        
                        ctx.moveTo(payload.x0 * w, payload.y0 * h);
                        ctx.lineTo(payload.x1 * w, payload.y1 * h);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    } else if (payload.type === 'cursor') {
                        setRemoteCursors(prev => ({
                            ...prev, 
                            [payload.user]: { x: payload.x, y: payload.y, color: payload.color }
                        }));
                    } else if (payload.type === 'laser') {
                         laserPoints.current.push({ x: payload.x * w, y: payload.y * h, time: Date.now(), remote: true });
                    } else if (payload.type === 'shape') {
                        ctx.beginPath();
                        ctx.strokeStyle = payload.color;
                        ctx.lineWidth = payload.thickness;
                        ctx.fillStyle = payload.color;
                        drawShape(ctx, 
                            {x: payload.x0 * w, y: payload.y0 * h}, 
                            {x: payload.x1 * w, y: payload.y1 * h}, 
                            payload.shapeType, 
                            payload.fill
                        );
                    } else if (payload.type === 'text') {
                         ctx.save();
                        ctx.font = `${payload.fontSize}px 'Cairo'`;
                        ctx.fillStyle = payload.color;
                        ctx.textBaseline = 'top';
                        const lines = payload.text.split('\n');
                        const lineHeight = payload.fontSize * 1.2;
                        lines.forEach((line, i) => {
                            ctx.fillText(line, payload.x * w, payload.y * h + (i * lineHeight));
                        });
                        ctx.restore();
                    } else if (payload.type === 'image' && payload.dataUrl) {
                        const img = new Image();
                        img.onload = () => {
                            // ارسم الخلفية البيضاء + النمط الحالي أولاً
                            drawBackground(ctx, w, h, payload.backgroundType || 'plain');
                            // رسم الصورة بنفس منطق الخلفية المحلية (cover مع الحفاظ على النسبة)
                            const ratio = Math.min(w / img.width, h / img.height);
                            const cw = img.width * ratio;
                            const ch = img.height * ratio;
                            const cx = (w - cw) / 2;
                            const cy = (h - ch) / 2;
                            ctx.drawImage(img, 0, 0, img.width, img.height, cx, cy, cw, ch);
                            // حفظ الحالة في التاريخ حتى تعمل خاصية التصدير
                            try {
                                if (typeof onSaveStep === 'function') {
                                    onSaveStep(canvas.toDataURL());
                                }
                            } catch (_) {}
                        };
                        img.src = payload.dataUrl;
                    } else if (payload.type === 'clear') {
                        redrawMainCanvas(); 
                    }
                };
                
                const channel = channelRef.current;
                const sub = channel.on('broadcast', { event: 'wb' }, ({ payload }) => handleBroadcast(payload)).subscribe();

                return () => {
                   // Cleanup handled by App unmount or disconnect
                };

            }, [isConnected, redrawMainCanvas]);


            const getCoords = (e) => {
                if (!containerRef.current) return { x: 0, y: 0 };
                const rect = containerRef.current.getBoundingClientRect();
                let clientX = 0, clientY = 0;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                return { x: clientX - rect.left, y: clientY - rect.top, nx: (clientX - rect.left)/rect.width, ny: (clientY - rect.top)/rect.height };
            };

            const broadcast = (data) => {
                if (isConnected && channelRef.current) {
                    channelRef.current.send({
                        type: 'broadcast',
                        event: 'wb',
                        payload: data
                    });
                }
            };

            const startDrawing = (e) => {
                if (!canWrite || tool === 'hand') return;
                const coords = getCoords(e);
                
                if (tool === 'text') {
                    if (textInput?.visible) {
                        finishText();
                    } else {
                        setTextInput({ x: coords.x, y: coords.y, nx: coords.nx, ny: coords.ny, visible: true, value: '' });
                    }
                    return;
                }

                setIsDrawing(true);
                setStartPoint(coords);
                setLastPoint(coords);

                if (['pen', 'eraser', 'highlighter'].includes(tool)) {
                    const ctx = canvasRef.current?.getContext('2d');
                    if (ctx) {
                        ctx.beginPath();
                        ctx.moveTo(coords.x, coords.y);
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.lineWidth = settings.thickness;
                        ctx.strokeStyle = tool === 'eraser' ? '#ffffff' : settings.color;
                        ctx.globalAlpha = tool === 'highlighter' ? 0.3 : 1.0;
                        if(tool === 'highlighter') ctx.lineWidth = settings.thickness * 2;
                    }
                }
            };

            const draw = (e) => {
                const coords = getCoords(e);

                if(isConnected) {
                    // Rate limit cursor updates
                    if(Math.random() > 0.5) broadcast({ type: 'cursor', x: coords.nx, y: coords.ny, color: settings.color, user: 'me' });
                }

                if (!canWrite && tool !== 'laser') {
                    return;
                }

                if (tool === 'laser') {
                    laserPoints.current.push({ x: coords.x, y: coords.y, time: Date.now() });
                    if(isConnected) broadcast({ type: 'laser', x: coords.nx, y: coords.ny });
                    return;
                }

                if (!isDrawing || !lastPoint) return;

                if (['pen', 'eraser', 'highlighter'].includes(tool)) {
                    const ctx = canvasRef.current?.getContext('2d');
                    if (ctx) {
                        ctx.beginPath();
                        ctx.moveTo(lastPoint.x, lastPoint.y);
                        ctx.lineTo(coords.x, coords.y);
                        ctx.stroke();
                        
                        if(isConnected) {
                            broadcast({
                                type: 'draw',
                                tool: tool,
                                x0: lastPoint.nx, y0: lastPoint.ny,
                                x1: coords.nx, y1: coords.ny,
                                color: settings.color,
                                thickness: tool === 'highlighter' ? settings.thickness * 2 : settings.thickness,
                                opacity: tool === 'highlighter' ? 0.3 : 1
                            });
                        }
                        setLastPoint(coords);
                    }
                } else if (tool === 'shape') {
                    const tempCtx = tempCanvasRef.current?.getContext('2d');
                    if (tempCtx && startPoint) {
                        tempCtx.clearRect(0, 0, tempCanvasRef.current.width, tempCanvasRef.current.height);
                        tempCtx.strokeStyle = settings.color;
                        tempCtx.lineWidth = settings.thickness;
                        tempCtx.fillStyle = settings.color;
                        drawShape(tempCtx, startPoint, coords, shapeType, settings.isFilled);
                    }
                }
            };

            const stopDrawing = (e) => {
                if (!isDrawing) return;
                setIsDrawing(false);

                if (tool === 'shape' && startPoint) {
                     const coords = getCoords(e); 
                     
                     const ctx = canvasRef.current?.getContext('2d');
                     const tempCtx = tempCanvasRef.current?.getContext('2d');
                     if(ctx && tempCtx) {
                         ctx.drawImage(tempCanvasRef.current, 0, 0);
                         tempCtx.clearRect(0, 0, tempCanvasRef.current.width, tempCanvasRef.current.height);
                         
                         if(isConnected) {
                             broadcast({
                                 type: 'shape',
                                 shapeType: shapeType,
                                 x0: startPoint.nx, y0: startPoint.ny,
                                 x1: coords.nx, y1: coords.ny,
                                 color: settings.color,
                                 thickness: settings.thickness,
                                 fill: settings.isFilled
                             });
                         }
                         ctx.globalAlpha = 1;
                     }
                }

                if(canvasRef.current) {
                    onSaveStep(canvasRef.current.toDataURL());
                }
                setStartPoint(null);
                setLastPoint(null);
            };

            const finishText = () => {
                if (!textInput || !textInput.visible || !textInput.value) {
                    setTextInput(null);
                    return;
                }
                const ctx = canvasRef.current?.getContext('2d');
                if (ctx) {
                    ctx.save();
                    ctx.font = `${settings.thickness}px 'Cairo'`;
                    ctx.fillStyle = settings.color;
                    ctx.textBaseline = 'top';
                    const lines = textInput.value.split('\n');
                    const lineHeight = settings.thickness * 1.2;
                    lines.forEach((line, i) => {
                        ctx.fillText(line, textInput.x, textInput.y + (i * lineHeight));
                    });
                    ctx.restore();
                    
                    if(isConnected) {
                        broadcast({
                            type: 'text',
                            text: textInput.value,
                            x: textInput.nx, y: textInput.ny,
                            color: settings.color,
                            fontSize: settings.thickness
                        });
                    }

                    onSaveStep(canvasRef.current.toDataURL());
                }
                setTextInput(null);
            };

            // Laser Loop
            useEffect(() => {
                const animate = () => {
                    const tempCtx = tempCanvasRef.current?.getContext('2d');
                    if (!tempCtx || !tempCanvasRef.current) return;

                    // Only clear if we are not drawing a shape
                    if(!isDrawing || tool !== 'shape') {
                        tempCtx.clearRect(0, 0, tempCanvasRef.current.width, tempCanvasRef.current.height);
                    }

                    // Draw Remote Cursors
                    Object.values(remoteCursors).forEach(c => {
                         const cx = c.x * tempCanvasRef.current.width;
                         const cy = c.y * tempCanvasRef.current.height;
                         tempCtx.beginPath();
                         tempCtx.fillStyle = c.color || 'red';
                         tempCtx.arc(cx, cy, 5, 0, Math.PI * 2);
                         tempCtx.fill();
                         tempCtx.font = '10px Cairo';
                         tempCtx.fillText('User', cx + 8, cy);
                    });

                    const now = Date.now();
                    laserPoints.current = laserPoints.current.filter(p => now - p.time < 800);

                    if (laserPoints.current.length > 0) {
                        tempCtx.lineCap = 'round';
                        tempCtx.lineJoin = 'round';
                        for(let i = 1; i < laserPoints.current.length; i++) {
                            const p1 = laserPoints.current[i-1];
                            const p2 = laserPoints.current[i];
                            if(Math.abs(p1.x - p2.x) > 50) continue; 

                            const age = now - p2.time;
                            const opacity = 1 - (age / 800);
                            tempCtx.beginPath();
                            tempCtx.moveTo(p1.x, p1.y);
                            tempCtx.lineTo(p2.x, p2.y);
                            tempCtx.lineWidth = 4;
                            tempCtx.strokeStyle = `rgba(239, 68, 68, ${opacity})`;
                            tempCtx.stroke();
                        }
                    }
                    laserReqRef.current = requestAnimationFrame(animate);
                };
                laserReqRef.current = requestAnimationFrame(animate);
                return () => cancelAnimationFrame(laserReqRef.current);
            }, [tool, isDrawing, remoteCursors]);

            useEffect(() => {
                if (textInput?.visible && textAreaRef.current) {
                    textAreaRef.current.focus();
                }
            }, [textInput?.visible]);

            return (
                <div 
                    ref={containerRef} 
                    className={`relative w-full h-full bg-white overflow-hidden touch-none ${
                        !canWrite
                            ? 'cursor-not-allowed'
                            : tool === 'text'
                                ? 'cursor-text'
                                : tool === 'hand'
                                    ? 'cursor-grab'
                                    : tool === 'eraser'
                                        ? 'cursor-eraser'
                                        : 'cursor-pen'
                    }`}
                    onMouseDown={startDrawing}
                    onMouseMove={draw}
                    onMouseUp={stopDrawing}
                    onMouseLeave={stopDrawing}
                    onTouchStart={startDrawing}
                    onTouchMove={draw}
                    onTouchEnd={stopDrawing}
                >
                    <canvas ref={canvasRef} className="absolute top-0 left-0 w-full h-full z-0 pointer-events-none" />
                    <canvas ref={tempCanvasRef} className="absolute top-0 left-0 w-full h-full z-10 pointer-events-none" />
                    {textInput?.visible && (
                        <textarea
                            ref={textAreaRef}
                            value={textInput.value}
                            onChange={(e) => setTextInput({ ...textInput, value: e.target.value })}
                            onBlur={finishText}
                            className="absolute z-50 bg-white/80 border border-blue-500 rounded p-1 outline-none resize-none shadow-xl"
                            style={{
                                left: textInput.x,
                                top: textInput.y,
                                fontSize: `${settings.thickness}px`,
                                color: settings.color,
                                fontFamily: 'Cairo',
                                minWidth: '150px',
                                minHeight: '1.5em'
                            }}
                            placeholder="اكتب..."
                            dir="auto"
                        />
                    )}
                </div>
            );
        };

        const App = () => {
            const [currentTool, setCurrentTool] = useState('pen');
            const [settings, setSettings] = useState({ color: '#000000', thickness: 3, isFilled: false });
            const [shapeType, setShapeType] = useState('rectangle');
            const [backgroundType, setBackgroundType] = useState('plain');
            const [pages, setPages] = useState(['']);
            const [currentPageIndex, setCurrentPageIndex] = useState(0);
            const [history, setHistory] = useState([]);
            const [historyStep, setHistoryStep] = useState(-1);
            const [backgroundImage, setBackgroundImage] = useState(null);
            
            // Session State
            const [isSessionModalOpen, setIsSessionModalOpen] = useState(false);
            const [isConnected, setIsConnected] = useState(false);
            const [supabaseClient, setSupabaseClient] = useState(null);
            const channelRef = useRef(null);
            const [roomId, setRoomId] = useState(null);
            const [isTeacher, setIsTeacher] = useState(false);
            const [studentsCanWrite, setStudentsCanWrite] = useState(true);

            // Detect role from URL (role=teacher => محاضر)
            useEffect(() => {
                try {
                    const params = new URLSearchParams(window.location.search);
                    const role = params.get('role');
                    if (role === 'teacher') {
                        setIsTeacher(true);
                    }
                } catch (e) {}
            }, []);

            // Auto-join if ?room= is present in URL
            useEffect(() => {
                try {
                    const params = new URLSearchParams(window.location.search);
                    const qRoom = params.get('room');
                    if (qRoom && !isConnected && !roomId) {
                        handleConnectSession(qRoom);
                    }
                } catch (e) {}
            }, [isConnected, roomId]);

            const handleConnectSession = async (room) => {
                try {
                    const client = window.supabaseClient || (window.initializeSupabase && window.initializeSupabase());
                    if (!client) throw new Error('تعذر تهيئة اتصال Supabase');
                    setSupabaseClient(client);
                    setRoomId(room);
                    
                    const channel = client.channel(`whiteboard:${room}`, { config: { broadcast: { self: false } } });
                    channel.subscribe((status) => {
                        if (status === 'SUBSCRIBED') {
                            setIsConnected(true);
                            setIsSessionModalOpen(false);
                        }
                    });
                    channelRef.current = channel;
                } catch (e) {
                    alert('فشل الاتصال: ' + e.message);
                }
            };

            const saveToHistory = useCallback((dataURL) => {
                const newHistory = history.slice(0, historyStep + 1);
                newHistory.push(dataURL);
                if (newHistory.length > 20) newHistory.shift();
                setHistory(newHistory);
                setHistoryStep(newHistory.length - 1);
                const newPages = [...pages];
                newPages[currentPageIndex] = dataURL;
                setPages(newPages);
            }, [history, historyStep, pages, currentPageIndex]);

            const handleUndo = () => {
                if (historyStep > 0) setHistoryStep(prev => prev - 1);
            };

            const handleRedo = () => {
                if (historyStep < history.length - 1) setHistoryStep(prev => prev + 1);
            };

            const handleClear = () => {
                if (window.confirm('مسح السبورة؟')) {
                    saveToHistory('');
                    setHistory(['']);
                    setHistoryStep(0);
                    setBackgroundImage(null);
                    if(isConnected && channelRef.current) {
                        channelRef.current.send({ type: 'broadcast', event: 'wb', payload: { type: 'clear' } });
                    }
                }
            };

             const handleImageUpload = (e) => {
                const file = e.target.files?.[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const dataUrl = event.target.result;
                    const img = new Image();
                    img.onload = () => {
                        setBackgroundImage(img);
                        // عند وجود جلسة، أرسل الصورة لباقي المشاركين
                        if (isConnected && channelRef.current) {
                            try {
                                channelRef.current.send({
                                    type: 'broadcast',
                                    event: 'wb',
                                    payload: {
                                        type: 'image',
                                        dataUrl,
                                        backgroundType
                                    }
                                });
                            } catch (_) {}
                        }
                    };
                    img.src = dataUrl;
                };
                reader.readAsDataURL(file);
            };

            const handleExport = () => {
                const link = document.createElement('a');
                link.download = `whiteboard-${Date.now()}.png`;
                if (history[historyStep]) {
                    link.href = history[historyStep];
                    link.click();
                } else {
                    alert("لا يوجد محتوى للحفظ");
                }
            };

            // Page Management
            const handleNextPage = () => {
                 if (currentPageIndex < pages.length - 1) {
                     loadPage(currentPageIndex + 1);
                 }
            };
            const handlePrevPage = () => {
                if (currentPageIndex > 0) {
                    loadPage(currentPageIndex - 1);
                }
            };
            const handleNewPage = () => {
                  const newPages = [...pages, ''];
                  setPages(newPages);
                  loadPage(newPages.length - 1);
            };
            const loadPage = (index) => {
                  setCurrentPageIndex(index);
                  const pageData = pages[index] || '';
                  setHistory([pageData]);
                  setHistoryStep(0);
            };

            const handleToggleStudentsWrite = () => {
                const next = !studentsCanWrite;
                setStudentsCanWrite(next);
                if (isConnected && channelRef.current) {
                    try {
                        channelRef.current.send({
                            type: 'broadcast',
                            event: 'control',
                            payload: { type: 'permissions', studentsCanWrite: next }
                        });
                    } catch (_) {}
                }
            };

            // Listen for teacher control messages (permissions)
            useEffect(() => {
                if (!isConnected || !channelRef.current) return;
                const channel = channelRef.current;
                const sub = channel
                    .on('broadcast', { event: 'control' }, ({ payload }) => {
                        if (payload && payload.type === 'permissions') {
                            setStudentsCanWrite(!!payload.studentsCanWrite);
                        }
                    })
                    .subscribe();

                return () => {
                    // cleanup handled elsewhere if needed
                };
            }, [isConnected]);

            return (
                <div className="flex flex-col h-screen w-full bg-slate-50 overflow-hidden">
                    <PropertiesBar 
                        tool={currentTool}
                        settings={settings}
                        setSettings={setSettings}
                        shapeType={shapeType}
                        setShapeType={setShapeType}
                        backgroundType={backgroundType}
                        setBackgroundType={setBackgroundType}
                        canUndo={historyStep > 0}
                        canRedo={historyStep < history.length - 1}
                        onUndo={handleUndo}
                        onRedo={handleRedo}
                        onClear={handleClear}
                        onExport={handleExport}
                        onSessionClick={() => setIsSessionModalOpen(true)}
                        isConnected={isConnected}
                        isTeacher={isTeacher}
                        studentsCanWrite={studentsCanWrite}
                        onToggleStudentsWrite={handleToggleStudentsWrite}
                        pageIndex={currentPageIndex}
                        totalPages={pages.length}
                        onNextPage={handleNextPage}
                        onPrevPage={handlePrevPage}
                        onNewPage={handleNewPage}
                    />
                    
                    <div className="flex flex-1 overflow-hidden relative">
                        <Toolbar currentTool={currentTool} setTool={setCurrentTool} onImageUpload={handleImageUpload} />
                        
                        <main className="flex-1 relative bg-white sm:m-4 sm:rounded-2xl shadow-lg border border-slate-200 overflow-hidden">
                            {isConnected && (
                                <div className="absolute top-2 left-2 bg-green-100 text-green-800 px-3 py-1 rounded-full text-xs z-30 flex items-center gap-2 opacity-80 pointer-events-none">
                                    <span className="w-2 h-2 bg-green-500 rounded-full animate-pulse"></span>
                                    بث مباشر: {roomId}
                                </div>
                            )}
                            <Whiteboard 
                                tool={currentTool}
                                settings={settings}
                                shapeType={shapeType}
                                backgroundType={backgroundType}
                                onSaveStep={saveToHistory}
                                snapshot={history[historyStep] || null}
                                backgroundImage={backgroundImage}
                                channelRef={channelRef}
                                isConnected={isConnected}
                                canWrite={isTeacher || studentsCanWrite}
                            />
                        </main>
                    </div>

                    <MobileToolbar currentTool={currentTool} setTool={setCurrentTool} onImageUpload={handleImageUpload} />
                    
                    <SessionModal 
                        isOpen={isSessionModalOpen} 
                        onClose={() => setIsSessionModalOpen(false)}
                        onConnect={handleConnectSession}
                        isConnecting={false}
                        initialRoomId={roomId}
                    />
                </div>
            );
        };

        const rootElement = document.getElementById('root');
        if (!rootElement) throw new Error("Root not found");
        const root = createRoot(rootElement);
        root.render(<App />);
    </script>
</body>
</html>
