<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…Ø­Ø±Ø± Ø§Ù„ØµÙˆØ± Ø§Ù„Ø°ÙƒÙŠ (Ù†ØµÙˆØµ + Ø±Ø³Ù…)</title>
    <!-- Tailwind CSS (stable CDN CSS to avoid production console warning) -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- Gemini API Key (provided) -->
    <script>
        window.GEMINI_API_KEY = 'AIzaSyDDQDLVkJkqQJgEUOEe0sF3bp77u5bQvCM';
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap');
        body { font-family: 'Cairo', sans-serif; }
        canvas { touch-action: none; } /* Prevent scrolling on mobile while drawing */
        .layers-list::-webkit-scrollbar { width: 6px; }
        .layers-list::-webkit-scrollbar-track { background: #f1f1f1; }
        .layers-list::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-white border-b px-6 py-4 flex justify-between items-center shadow-sm z-20">
        <div class="flex items-center gap-2">
            <div class="bg-gradient-to-r from-indigo-600 to-blue-600 p-2 rounded-lg text-white">
                <i data-lucide="wand-2"></i>
            </div>
            <h1 class="text-xl font-bold text-gray-800">Ù…Ø­Ø±Ø± Ø§Ù„ØµÙˆØ± Ø§Ù„Ø°ÙƒÙŠ (Ù†ØµÙˆØµ + Ø±Ø³Ù…)</h1>
        </div>
        
        <div class="flex gap-3 items-center">
            <div class="flex items-center gap-3">
                <!-- AI Text Edit Button -->
                <button id="aiEditBtn" class="flex items-center gap-2 px-4 py-2 rounded-lg text-white transition bg-gradient-to-r from-purple-600 to-blue-600 hover:opacity-90">
                    <i class="fas fa-magic"></i>
                    <span>ØªØ­Ø±ÙŠØ± Ø§Ù„Ù†Øµ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</span>
                </button>

                <!-- Toggle Original Image Preview -->
                <div id="toggleOriginalContainer" class="hidden items-center gap-2 bg-gray-100 p-1 rounded-lg">
                    <span class="text-xs font-medium text-gray-500 px-2">Ø¹Ø±Ø¶ Ø§Ù„Ø£ØµÙ„ÙŠØ©:</span>
                    <button id="toggleOriginalBtn" class="w-10 h-6 bg-gray-300 rounded-full p-1 relative transition-colors focus:outline-none">
                        <div id="toggleKnob" class="w-4 h-4 bg-white rounded-full shadow-sm transform transition-transform translate-x-0"></div>
                    </button>
                </div>
            </div>

            <button id="downloadBtn" disabled class="flex items-center gap-2 px-4 py-2 rounded-lg text-white transition bg-gray-300 cursor-not-allowed">
                <i data-lucide="download" width="18"></i>
                <span>ØªØµØ¯ÙŠØ±</span>
            </button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        
        <!-- Right Sidebar: Tools & Layers -->
        <aside class="w-80 bg-white border-l flex flex-col overflow-hidden shadow-sm z-10 relative">
            
            <!-- Upload Section -->
            <div class="p-5 border-b flex-shrink-0">
                <label class="flex flex-col items-center justify-center w-full h-20 border-2 border-dashed border-indigo-300 rounded-xl cursor-pointer bg-indigo-50 hover:bg-indigo-100 transition group">
                    <div class="flex flex-col items-center justify-center pt-2 pb-3">
                        <i data-lucide="upload" class="w-5 h-5 mb-1 text-indigo-500 group-hover:scale-110 transition"></i>
                        <p class="text-xs text-gray-500 font-medium">Ø±ÙØ¹ ØµÙˆØ±Ø©</p>
                    </div>
                    <input type="file" id="imageUpload" class="hidden" accept="image/*" />
                </label>
            </div>

            <!-- Controls Container -->
            <div id="controlsContainer" class="flex-1 overflow-y-auto p-5 space-y-6 opacity-50 pointer-events-none transition-opacity">
                
                <!-- Tools Toggle -->
                <div class="flex-shrink-0">
                    <label class="text-xs font-bold text-gray-400 uppercase mb-3 block">Ø§Ù„Ø£Ø¯ÙˆØ§Øª</label>
                    <div class="grid grid-cols-3 bg-gray-100 p-1 rounded-lg gap-1">
                        <button id="toolSelect" class="tool-btn flex flex-col items-center justify-center gap-1 py-2 rounded-md text-[10px] font-medium transition bg-white shadow text-indigo-600">
                            <i data-lucide="move" width="18"></i> ØªØ­Ø±ÙŠÙƒ
                        </button>
                        <button id="toolBox" class="tool-btn flex flex-col items-center justify-center gap-1 py-2 rounded-md text-[10px] font-medium transition text-gray-500 hover:bg-gray-200">
                            <i data-lucide="box-select" width="18"></i> Ù†Øµ / Ù†Ù‚Ø±
                        </button>
                        <button id="toolPen" class="tool-btn flex flex-col items-center justify-center gap-1 py-2 rounded-md text-[10px] font-medium transition text-gray-500 hover:bg-gray-200">
                            <i data-lucide="pen-tool" width="18"></i> Ù‚Ù„Ù…
                        </button>
                    </div>
                    <p class="text-[10px] text-gray-400 mt-1 text-center">Ù†ØµÙŠØ­Ø©: Ø§Ù†Ù‚Ø± Ø¨Ø§Ù„ØµÙˆØ±Ø© Ù„Ø¥Ø¶Ø§ÙØ© Ù†Øµ Ø³Ø±ÙŠØ¹</p>
                </div>

                <!-- Properties Panel (Dynamic based on selection) -->
                <div id="propertiesPanel" class="hidden space-y-4 flex-shrink-0 border p-3 rounded-lg bg-gray-50">
                    <div class="flex justify-between items-center border-b pb-2 mb-2">
                        <label class="text-xs font-bold text-indigo-600 uppercase" id="propTitle">Ø®ØµØ§Ø¦Øµ</label>
                    </div>

                    <!-- Text Properties (Only for Text Layer) -->
                    <div id="textPropsGroup" class="space-y-3 hidden">
                        <!-- Quick Stamps -->
                        <div class="grid grid-cols-4 gap-1 mb-2">
                            <button class="stamp-btn bg-white border hover:bg-green-50 text-green-600 rounded p-1 text-xs font-bold shadow-sm transition" data-text="âœ… ØµØ­">âœ… ØµØ­</button>
                            <button class="stamp-btn bg-white border hover:bg-red-50 text-red-600 rounded p-1 text-xs font-bold shadow-sm transition" data-text="âŒ Ø®Ø·Ø£">âŒ Ø®Ø·Ø£</button>
                            <button class="stamp-btn bg-white border hover:bg-blue-50 text-blue-600 rounded p-1 text-xs font-bold shadow-sm transition" data-text="â“ Ø³Ø¤Ø§Ù„">â“ Ø³Ø¤Ø§Ù„</button>
                            <button class="stamp-btn bg-white border hover:bg-gray-50 text-gray-600 rounded p-1 text-xs font-bold shadow-sm transition" data-text="ğŸ“ Ø¥Ø¬Ø§Ø¨Ø©">ğŸ“ Ø¥Ø¬Ø§Ø¨Ø©</button>
                        </div>

                        <div class="space-y-1">
                            <input type="text" id="propText" class="w-full p-2 border rounded-lg text-sm" placeholder="Ø§Ù„Ù†Øµ Ù‡Ù†Ø§...">
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <input type="number" id="propSize" class="w-full p-2 border rounded-lg text-sm" placeholder="Ø§Ù„Ø­Ø¬Ù…">
                            <select id="propFont" class="w-full p-2 border rounded-lg bg-white text-sm">
                                <option value="Cairo">Cairo</option>
                                <option value="Arial">Arial</option>
                                <option value="Tahoma">Tahoma</option>
                            </select>
                        </div>
                    </div>

                    <!-- Brush Properties (For Pen or Drawing Layer) -->
                    <div id="brushPropsGroup" class="space-y-3 hidden">
                        <div class="space-y-1">
                            <label class="text-xs text-gray-500 flex justify-between">
                                <span>Ø³Ù…Ùƒ Ø§Ù„Ø®Ø·</span>
                                <span id="brushSizeVal">5px</span>
                            </label>
                            <input type="range" id="propBrushSize" min="1" max="50" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>

                    <!-- Common Colors -->
                    <div class="space-y-1">
                        <div class="flex gap-2 items-center">
                            <!-- Main Color -->
                            <div class="flex-1 flex items-center gap-2 border p-2 rounded-lg bg-white" title="Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ">
                                <div class="w-4 h-4 rounded-full border" id="colorPreview"></div>
                                <input type="color" id="propColor" class="w-full h-6 rounded cursor-pointer border-0 p-0 bg-transparent opacity-0 absolute w-8">
                                <span class="text-xs text-gray-500 ml-6">Ø§Ù„Ù„ÙˆÙ†</span>
                            </div>
                            
                            <!-- BG Color (Text Only) -->
                            <div id="bgColorGroup" class="flex-1 flex items-center gap-2 border p-2 rounded-lg bg-white relative group hidden">
                                <div id="bgColorPreview" class="w-4 h-4 rounded border bg-gray-100 flex items-center justify-center text-[8px]">A</div>
                                <input type="color" id="propBgColor" class="absolute inset-0 opacity-0 cursor-pointer">
                                <span class="text-xs text-gray-500">Ø·Ù…Ø³</span>
                                <button id="autoBgBtn" class="absolute -top-2 -left-2 bg-indigo-600 text-white text-[9px] p-1 rounded-full opacity-0 group-hover:opacity-100 transition">Auto</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Layers List Section -->
                <div id="layersSection" class="flex-1 flex flex-col overflow-hidden pt-4 border-t">
                    <label class="text-xs font-bold text-gray-400 uppercase mb-3 flex-shrink-0">Ø·Ø¨Ù‚Ø§Øª Ø§Ù„ØªØ¹Ø¯ÙŠÙ„</label>
                    <div id="layersList" class="layers-list flex-1 overflow-y-auto space-y-2 pr-1">
                        <!-- Layers added dynamically -->
                        <div id="noLayersHint" class="text-center py-4 text-gray-400 text-sm italic">
                            Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ù„Ø¥Ø¶Ø§ÙØ© Ù†ØµÙˆØµ Ø£Ùˆ Ø±Ø³ÙˆÙ…Ø§Øª.
                        </div>
                    </div>
                </div>

            </div>
        </aside>

        <!-- Main Canvas Area -->
        <main class="flex-1 bg-gray-200 overflow-auto relative flex items-center justify-center p-8" id="mainArea">
            <div id="noImagePlaceholder" class="text-center text-gray-500 bg-white p-8 rounded-xl shadow-sm">
                <i data-lucide="image" class="w-20 h-20 mx-auto mb-4 text-indigo-200 block"></i>
                <p class="text-xl font-bold text-gray-700 mb-2">Ø§Ø¨Ø¯Ø£ Ø¨Ø±ÙØ¹ ØµÙˆØ±Ø©</p>
            </div>

            <div id="canvasWrapper" class="hidden relative shadow-2xl border-4 border-white bg-white cursor-crosshair" style="max-height: 90vh; max-width: 90vw;">
                <canvas id="canvas" class="block" style="max-height: 100%; max-width: 100%; object-fit: contain;"></canvas>
                <img id="originalImageOverlay" class="absolute inset-0 w-full h-full object-contain hidden pointer-events-none z-30" alt="Original Preview">
            </div>
        </main>

    </div>

    <!-- AI Text Edit Modal -->
    <div id="aiEditModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl w-full max-w-2xl mx-4">
            <div class="p-4 border-b flex justify-between items-center">
                <h3 class="text-lg font-bold text-gray-800">ØªØ­Ø±ÙŠØ± Ø§Ù„Ù†Øµ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</h3>
                <button id="closeAiModal" class="text-gray-500 hover:text-gray-700">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="p-4">
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Ø§Ù„Ù†Øµ Ø§Ù„Ø­Ø§Ù„ÙŠ:</label>
                    <textarea id="currentText" class="w-full p-3 border rounded-lg h-32" readonly></textarea>
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª (Ø§Ø®ØªÙŠØ§Ø±ÙŠ):</label>
                    <input type="text" id="aiInstructions" class="w-full p-3 border rounded-lg" placeholder="Ù…Ø«Ø§Ù„: ØµØ­Ø­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¥Ù…Ù„Ø§Ø¦ÙŠØ©ØŒ Ø£Ùˆ Ø£Ø¹Ø¯ Ø§Ù„ØµÙŠØ§ØºØ© Ø¨Ø´ÙƒÙ„ Ø£ÙƒØ§Ø¯ÙŠÙ…ÙŠ">
                </div>
                <div class="flex justify-end gap-3">
                    <button id="cancelAiEdit" class="px-4 py-2 border rounded-lg text-gray-700 hover:bg-gray-100">Ø¥Ù„ØºØ§Ø¡</button>
                    <button id="applyAiEdit" class="px-4 py-2 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-lg hover:opacity-90 flex items-center gap-2">
                        <span>ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª</span>
                        <i class="fas fa-magic"></i>
                    </button>
                </div>
                <div id="aiLoading" class="mt-4 text-center hidden">
                    <div class="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-indigo-600"></div>
                    <p class="mt-2 text-gray-600">Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Øµ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Template for Layer Item -->
    <template id="layerItemTemplate">
        <div class="layer-item flex items-center gap-2 p-2 rounded-lg bg-gray-50 border border-gray-200 hover:bg-gray-100 transition cursor-pointer group select-none">
            <button class="layer-visible-btn text-gray-400 hover:text-indigo-600 transition p-1">
                <i data-lucide="eye" width="14"></i>
            </button>
            <div class="layer-icon text-gray-400">
                <i data-lucide="type" width="14"></i>
            </div>
            <div class="layer-name flex-1 truncate text-xs font-medium text-gray-700">
                Layer Name
            </div>
            <button class="layer-delete-btn text-gray-300 hover:text-red-500 transition p-1 opacity-0 group-hover:opacity-100">
                <i data-lucide="trash-2" width="14"></i>
            </button>
        </div>
    </template>

    <script>
        // --- Global State ---
        let image = null;
        // layers array can hold:
        // 1. Text Box: { type: 'text', id, x, y, w, h, text, fontSize, color, bgColor, calculatedBg, fontFamily, visible }
        // 2. Drawing: { type: 'drawing', id, points: [{x,y}], color, size, visible }
        let layers = []; 
        let selectedId = null;
        let mode = 'select'; // 'select', 'box', 'pen'
        let showOriginal = false;

        // Interaction State
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let currentItem = null; // For temp drawing/box creation

        // Initialize UI elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const aiEditBtn = document.getElementById('aiEditBtn');
        const aiEditModal = document.getElementById('aiEditModal');
        const closeAiModal = document.getElementById('closeAiModal');
        const cancelAiEdit = document.getElementById('cancelAiEdit');
        const applyAiEdit = document.getElementById('applyAiEdit');
        const currentText = document.getElementById('currentText');
        const aiInstructions = document.getElementById('aiInstructions');
        const aiLoading = document.getElementById('aiLoading');
        const uploadInput = document.getElementById('imageUpload');
        const downloadBtn = document.getElementById('downloadBtn');
        const controlsContainer = document.getElementById('controlsContainer');
        
        // Tools
        const tools = {
            select: document.getElementById('toolSelect'),
            box: document.getElementById('toolBox'),
            pen: document.getElementById('toolPen')
        };

        // Properties
        const propsPanel = document.getElementById('propertiesPanel');
        const inputs = {
            title: document.getElementById('propTitle'),
            textGroup: document.getElementById('textPropsGroup'),
            text: document.getElementById('propText'),
            size: document.getElementById('propSize'),
            font: document.getElementById('propFont'),
            brushGroup: document.getElementById('brushPropsGroup'),
            brushSize: document.getElementById('propBrushSize'),
            brushSizeVal: document.getElementById('brushSizeVal'),
            color: document.getElementById('propColor'),
            colorPreview: document.getElementById('colorPreview'),
            bgGroup: document.getElementById('bgColorGroup'),
            bgColor: document.getElementById('propBgColor'),
            bgColorPreview: document.getElementById('bgColorPreview'),
            autoBgBtn: document.getElementById('autoBgBtn')
        };

        // Initialize Lucide
        lucide.createIcons();

        // Helper: toast message
        function showTempMessage(message, isError = false) {
            const msg = document.createElement('div');
            msg.className = `fixed bottom-4 right-4 px-6 py-3 rounded-lg shadow-lg text-white font-medium text-sm z-50 transition-all duration-300 transform ${
                isError ? 'bg-red-500' : 'bg-green-600'
            }`;
            msg.textContent = message;
            document.body.appendChild(msg);
            setTimeout(() => {
                msg.style.opacity = '0';
                msg.style.transform = 'translateY(20px)';
                setTimeout(() => msg.remove(), 300);
            }, 2500);
        }

        // Gemini endpoint (use global key if provided)
        const GEMINI_KEY = (window.GEMINI_API_KEY || 'AIzaSyDDQDLVkJkqQJgEUOEe0sF3bp77u5bQvCM').trim();
        const GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${GEMINI_KEY}`;

        // Robust multi-model fallback to handle 403/404 or model availability
        async function geminiGenerate(payload){
            // Use stable, widely-available models first
            const models = [
                'gemini-1.5-flash',
                'gemini-1.5-pro'
            ];
            for (const m of models){
                // Try query param auth
                try{
                    const urlQP = `https://generativelanguage.googleapis.com/v1beta/models/${m}:generateContent?key=${GEMINI_KEY}`;
                    const res = await fetch(urlQP, { method:'POST', headers:{ 'Content-Type':'application/json', 'Accept':'application/json' }, body: JSON.stringify(payload)});
                    const data = await res.json();
                    const edited = data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                    if (res.ok && edited) return edited;
                }catch(err){ /* continue */ }
                // Try header auth
                try{
                    const urlHD = `https://generativelanguage.googleapis.com/v1beta/models/${m}:generateContent`;
                    const res2 = await fetch(urlHD, { method:'POST', headers:{ 'Content-Type':'application/json', 'Accept':'application/json', 'x-goog-api-key': GEMINI_KEY }, body: JSON.stringify(payload)});
                    const data2 = await res2.json();
                    const edited2 = data2?.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
                    if (res2.ok && edited2) return edited2;
                }catch(err2){ /* continue */ }
            }
            throw new Error('NO_MODEL_RESPONSE');
        }

        // Try backend first (on Vercel backend domain) then fallback to Gemini if backend unavailable
        async function backendOrGemini(textToEdit, instructions){
            const question = `Ø£Ø¹Ø¯ ØµÙŠØ§ØºØ© ÙˆØªØ­Ø³ÙŠÙ† Ù‡Ø°Ø§ Ø§Ù„Ù†Øµ Ù„ÙŠÙƒÙˆÙ† Ù…Ù†Ø§Ø³Ø¨Ø§Ù‹ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¹Ù„Ù‰ ØµÙˆØ±Ø© ØªØ¹Ù„ÙŠÙ…ÙŠØ©. Ø£Ø¹Ø¯ Ø§Ù„Ù†Øµ ÙÙ‚Ø· Ø¯ÙˆÙ† Ø´Ø±Ø­ Ø¥Ø¶Ø§ÙÙŠ.\n\nØ§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª: ${instructions}\n\nØ§Ù„Ù†Øµ:\n${textToEdit}`;
            const BACKEND_BASE = 'https://student-platform-backend-one.vercel.app';
            // Backend first (directly to backend project)
            try{
                const r = await fetch(`${BACKEND_BASE}/api/ai/ask`, { method:'POST', headers:{'Content-Type':'application/json','Accept':'application/json'}, body: JSON.stringify({ question, context: '' }) });
                const j = await r.json();
                const edited = (j && j.response || '').trim();
                if (r.ok && edited) return edited;
            }catch(_){ /* ignore */ }
            // Fallback to Gemini direct
            const payload = { contents: [{ parts: [{ text: question }]}] };
            return await geminiGenerate(payload);
        }

        // AI Text Editing
        let currentEditingLayer = null;

        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // ...
        });

        // Update properties panel when a layer is selected
        function updatePropsPanel() {
            const layer = layers.find(l => l.id === selectedId);
            if (!layer) {
                propsPanel.classList.add('hidden');
                return;
            }
            // ...
        }

        // AI Text Edit Event Listeners
        aiEditBtn.addEventListener('click', () => {
            if (selectedId !== null && layers.find(l => l.id === selectedId).type === 'text') {
                currentEditingLayer = selectedId;
                currentText.value = layers.find(l => l.id === selectedId).text || '';
                aiInstructions.value = '';
                aiEditModal.classList.remove('hidden');
            } else {
                showTempMessage('Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ Ù†Øµ Ù„ØªØ¹Ø¯ÙŠÙ„Ù‡', true);
            }
        });

        closeAiModal.addEventListener('click', () => {
            aiEditModal.classList.add('hidden');
        });

        cancelAiEdit.addEventListener('click', () => {
            aiEditModal.classList.add('hidden');
        });

        applyAiEdit.addEventListener('click', async () => {
            const layer = layers.find(l => l.id === selectedId && l.type === 'text');
            if (!layer) { showTempMessage('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø·Ø¨Ù‚Ø© Ù†ØµÙŠØ© Ù…Ø­Ø¯Ø¯Ø©', true); return; }

            const textToEdit = (currentText.value || '').trim();
            if (!textToEdit) { showTempMessage('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ù†Øµ Ù„Ù„ØªØ­Ø±ÙŠØ±', true); return; }

            aiLoading.classList.remove('hidden');
            try {
                const instructions = (aiInstructions.value || 'Ø­Ø³Ù‘Ù† ØµÙŠØ§ØºØ© Ø§Ù„Ù†Øµ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¹Ù†Ù‰').trim();
                const edited = await backendOrGemini(textToEdit, instructions);
                layer.text = edited;
                updatePropsPanel();
                render();
                aiEditModal.classList.add('hidden');
                showTempMessage('ØªÙ… ØªØ­Ø±ÙŠØ± Ø§Ù„Ù†Øµ Ø¨Ù†Ø¬Ø§Ø­');
            } catch (e) {
                console.error(e);
                showTempMessage('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Øµ', true);
            } finally {
                aiLoading.classList.add('hidden');
            }
        });

        downloadBtn.addEventListener('click', () => {
            if (!image) return;
            const prevSel = selectedId;
            selectedId = null;
            render();
            const link = document.createElement('a');
            link.download = 'smart-edit.png';
            link.href = canvas.toDataURL();
            link.click();
            selectedId = prevSel;
            render();
        });

        // --- Core editor logic ---
        uploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    image = img;
                    layers = [];
                    selectedId = null;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    document.getElementById('originalImageOverlay').src = img.src;

                    document.getElementById('noImagePlaceholder').classList.add('hidden');
                    document.getElementById('canvasWrapper').classList.remove('hidden');
                    document.getElementById('toggleOriginalContainer').classList.remove('hidden');
                    controlsContainer.classList.remove('opacity-50', 'pointer-events-none');
                    downloadBtn.disabled = false;
                    downloadBtn.classList.remove('bg-gray-300', 'cursor-not-allowed');
                    downloadBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');

                    setMode('box');
                    updateLayersList();
                    render();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        });

        function setMode(newMode) {
            mode = newMode;
            Object.values(tools).forEach(btn => {
                btn.classList.remove('bg-white', 'shadow', 'text-indigo-600');
                btn.classList.add('text-gray-500', 'hover:bg-gray-200');
            });
            tools[newMode].classList.add('bg-white', 'shadow', 'text-indigo-600');
            tools[newMode].classList.remove('text-gray-500', 'hover:bg-gray-200');

            if (mode === 'select') canvas.style.cursor = 'default';
            else if (mode === 'pen') canvas.style.cursor = 'crosshair';
            else canvas.style.cursor = 'text';

            if (mode !== 'select') {
                selectedId = null;
                updatePropsPanel();
                render();
            } else {
                updatePropsPanel();
            }
        }
        Object.keys(tools).forEach(k => tools[k].addEventListener('click', () => setMode(k)));

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (!image || showOriginal) return;
            const pos = getPos(e);
            isDragging = true;
            dragStart = pos;

            if (mode === 'select') {
                const clicked = [...layers].reverse().find(l => {
                    if (!l.visible) return false;
                    if (l.type === 'text') return pos.x >= l.x && pos.x <= l.x + l.w && pos.y >= l.y && pos.y <= l.y + l.h;
                    if (l.type === 'drawing') return l.points.some(p => Math.abs(p.x - pos.x) < 10 && Math.abs(p.y - pos.y) < 10);
                    return false;
                });
                selectedId = clicked ? clicked.id : null;
                updatePropsPanel();
                updateLayersList();
                render();
            } else if (mode === 'box') {
                currentItem = { x: pos.x, y: pos.y, w: 0, h: 0 };
            } else if (mode === 'pen') {
                const startColor = inputs.color.value;
                const newLayer = { id: Date.now(), type: 'drawing', points: [{x: pos.x, y: pos.y}], color: startColor, size: parseInt(inputs.brushSize.value), visible: true };
                layers.push(newLayer);
                selectedId = newLayer.id;
                currentItem = newLayer;
                render();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging || showOriginal) return;
            const pos = getPos(e);
            if (mode === 'select' && selectedId) {
                const layer = layers.find(l => l.id === selectedId);
                if (layer && layer.type === 'text') {
                    const dx = pos.x - dragStart.x; const dy = pos.y - dragStart.y;
                    layer.x += dx; layer.y += dy; dragStart = pos; render();
                }
            } else if (mode === 'box' && currentItem) {
                currentItem.w = pos.x - currentItem.x; currentItem.h = pos.y - currentItem.y; render();
            } else if (mode === 'pen' && currentItem) {
                currentItem.points.push({x: pos.x, y: pos.y}); render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (mode === 'box' && currentItem) {
                const isClick = Math.abs(currentItem.w) < 5 && Math.abs(currentItem.h) < 5;
                let x, y, w, h;
                if (isClick) { w = 120; h = 50; x = currentItem.x - w/2; y = currentItem.y - h/2; }
                else { x = currentItem.w < 0 ? currentItem.x + currentItem.w : currentItem.x; y = currentItem.h < 0 ? currentItem.y + currentItem.h : currentItem.y; w = Math.abs(currentItem.w); h = Math.abs(currentItem.h); }
                if (isClick || (w > 10 && h > 10)) {
                    const calculatedBg = getAverageBgColor(x, y, w, h);
                    const newLayer = { id: Date.now(), type: 'text', x, y, w, h, text: 'Ù†Øµ Ø¬Ø¯ÙŠØ¯', fontSize: Math.max(16, Math.floor(h*0.6)), color: '#000000', bgColor: 'auto', calculatedBg, fontFamily: 'Cairo', visible: true };
                    layers.push(newLayer); selectedId = newLayer.id; setMode('select');
                }
            } else if (mode === 'pen') { updateLayersList(); updatePropsPanel(); }
            isDragging = false; currentItem = null; render();
        });

        function render() {
            if (!canvas || !image) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(image, 0, 0);
            if (showOriginal) return;
            if (mode === 'box' && currentItem) {
                ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2; ctx.setLineDash([5,5]);
                if (Math.abs(currentItem.w) > 5 || Math.abs(currentItem.h) > 5) ctx.strokeRect(currentItem.x, currentItem.y, currentItem.w, currentItem.h);
                ctx.setLineDash([]);
            }
            layers.forEach(l => {
                if (!l.visible) return;
                if (l.type === 'text') {
                    ctx.fillStyle = l.bgColor === 'auto' ? (l.calculatedBg || '#fff') : l.bgColor;
                    ctx.fillRect(l.x, l.y, l.w, l.h);
                    ctx.fillStyle = l.color; ctx.font = `bold ${l.fontSize}px ${l.fontFamily}`; ctx.textBaseline = 'middle'; ctx.textAlign = 'center';
                    ctx.save(); ctx.beginPath(); ctx.rect(l.x, l.y, l.w, l.h); ctx.clip(); ctx.fillText(l.text, l.x + l.w/2, l.y + l.h/2); ctx.restore();
                    if (l.id === selectedId && mode === 'select') { ctx.strokeStyle = '#4f46e5'; ctx.lineWidth = 3; ctx.strokeRect(l.x, l.y, l.w, l.h); }
                } else if (l.type === 'drawing') {
                    if (l.points.length < 2) return;
                    ctx.strokeStyle = l.color; ctx.lineWidth = l.size; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                    ctx.beginPath(); ctx.moveTo(l.points[0].x, l.points[0].y); for (let i=1;i<l.points.length;i++){ ctx.lineTo(l.points[i].x, l.points[i].y);} ctx.stroke();
                    if (l.id === selectedId && mode === 'select') { ctx.save(); ctx.strokeStyle = 'rgba(79,70,229,0.3)'; ctx.lineWidth = l.size + 6; ctx.stroke(); ctx.restore(); }
                }
            });
        }

        function updatePropsPanel() {
            const layer = layers.find(l => l.id === selectedId);
            if (!layer) { propsPanel.classList.add('hidden'); return; }
            propsPanel.classList.remove('hidden');
            if (layer.type === 'text') {
                inputs.title.textContent = 'Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù†Øµ'; inputs.textGroup.classList.remove('hidden'); inputs.bgGroup.classList.remove('hidden'); inputs.brushGroup.classList.add('hidden');
                inputs.text.value = layer.text; inputs.size.value = layer.fontSize; inputs.font.value = layer.fontFamily;
                const isAuto = layer.bgColor === 'auto'; inputs.bgColorPreview.textContent = isAuto ? 'A' : ''; inputs.bgColorPreview.style.backgroundColor = isAuto ? layer.calculatedBg : layer.bgColor;
            } else {
                inputs.title.textContent = 'Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø±Ø³Ù…'; inputs.textGroup.classList.add('hidden'); inputs.bgGroup.classList.add('hidden'); inputs.brushGroup.classList.remove('hidden');
                inputs.brushSize.value = layer.size; inputs.brushSizeVal.textContent = layer.size + 'px';
            }
            inputs.color.value = layer.color; inputs.colorPreview.style.backgroundColor = layer.color;
        }

        function updateLayer(key, val) {
            if (!selectedId) return; const layer = layers.find(l => l.id === selectedId); if (!layer) return; layer[key] = val; render();
            if (key === 'text') updateLayersList(); if (key === 'color') inputs.colorPreview.style.backgroundColor = val; if (key === 'size') inputs.brushSizeVal.textContent = val + 'px'; if (key === 'bgColor') updatePropsPanel();
        }

        inputs.text.addEventListener('input', e => updateLayer('text', e.target.value));
        inputs.size.addEventListener('input', e => updateLayer('fontSize', parseInt(e.target.value)));
        inputs.font.addEventListener('change', e => updateLayer('fontFamily', e.target.value));
        inputs.color.addEventListener('input', e => updateLayer('color', e.target.value));
        inputs.brushSize.addEventListener('input', e => updateLayer('size', parseInt(e.target.value)));
        inputs.bgColor.addEventListener('input', e => updateLayer('bgColor', e.target.value));
        inputs.autoBgBtn.addEventListener('click', () => { const l = layers.find(l => l.id === selectedId); if (l) { l.calculatedBg = getAverageBgColor(l.x, l.y, l.w, l.h); updateLayer('bgColor', 'auto'); } });

        const layersContainer = document.getElementById('layersList');
        const tmpl = document.getElementById('layerItemTemplate');
        function updateLayersList() {
            const noHint = document.getElementById('noLayersHint');
            // Remove only previous layer items; keep the hint element in DOM
            layersContainer.querySelectorAll('.layer-item').forEach(el => el.remove());
            if (layers.length === 0) {
                if (noHint) noHint.classList.remove('hidden');
                return;
            }
            if (noHint) noHint.classList.add('hidden');
            [...layers].reverse().forEach(l => {
                const item = tmpl.content.cloneNode(true).firstElementChild;

                if (l.id === selectedId) { item.classList.add('bg-indigo-50','border-indigo-200'); item.classList.remove('bg-gray-50','border-gray-200'); }
                const icon = item.querySelector('.layer-icon i'); const name = item.querySelector('.layer-name');
                if (l.type === 'text') { icon.setAttribute('data-lucide','type'); name.textContent = l.text || 'Ù†Øµ ÙØ§Ø±Øº'; }
                else { icon.setAttribute('data-lucide','pen-tool'); name.textContent = `Ø±Ø³Ù… ÙŠØ¯ÙˆÙŠ (${l.color})`; }
                const visIcon = item.querySelector('.layer-visible-btn i'); visIcon.setAttribute('data-lucide', l.visible ? 'eye' : 'eye-off'); if (!l.visible) item.querySelector('.layer-visible-btn').classList.add('text-gray-300');
                item.querySelector('.layer-visible-btn').addEventListener('click', (e) => { e.stopPropagation(); l.visible = !l.visible; render(); updateLayersList(); });
                item.querySelector('.layer-delete-btn').addEventListener('click', (e) => { e.stopPropagation(); layers = layers.filter(x => x.id !== l.id); if (selectedId === l.id) { selectedId = null; updatePropsPanel(); } render(); updateLayersList(); });
                item.addEventListener('click', () => { selectedId = l.id; setMode('select'); updatePropsPanel(); updateLayersList(); render(); });
                layersContainer.appendChild(item);
            });
            lucide.createIcons();
        }

        function getAverageBgColor(x, y, w, h) {
            try {
                const data = ctx.getImageData(Math.max(0, x-5), Math.max(0, y), 5, Math.max(1, h)).data;
                let r=0,g=0,b=0,c=0; for (let i=0;i<data.length;i+=4){ r+=data[i]; g+=data[i+1]; b+=data[i+2]; c++; }
                if (c===0) return '#ffffff'; r=Math.floor(r/c); g=Math.floor(g/c); b=Math.floor(b/c); return `rgb(${r},${g},${b})`;
            } catch { return '#ffffff'; }
        }

        document.getElementById('toggleOriginalBtn').addEventListener('click', function(){
            showOriginal = !showOriginal; const knob = document.getElementById('toggleKnob');
            if (showOriginal) { this.classList.add('bg-indigo-500'); this.classList.remove('bg-gray-300'); knob.classList.add('translate-x-4'); document.getElementById('originalImageOverlay').classList.remove('hidden'); canvas.style.pointerEvents='none'; }
            else { this.classList.remove('bg-indigo-500'); this.classList.add('bg-gray-300'); knob.classList.remove('translate-x-4'); document.getElementById('originalImageOverlay').classList.add('hidden'); canvas.style.pointerEvents='auto'; render(); }
        });
    </script>
</body>
</html>

