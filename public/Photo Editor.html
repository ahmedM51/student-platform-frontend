<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…Ø­Ø±Ø± Ø§Ù„ØµÙˆØ± Ø§Ù„Ø°ÙƒÙŠ (Ù†ØµÙˆØµ + Ø±Ø³Ù…)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;600;700&display=swap');
        body { font-family: 'Cairo', sans-serif; }
        canvas { touch-action: none; } /* Prevent scrolling on mobile while drawing */
        .layers-list::-webkit-scrollbar { width: 6px; }
        .layers-list::-webkit-scrollbar-track { background: #f1f1f1; }
        .layers-list::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-white border-b px-6 py-4 flex justify-between items-center shadow-sm z-20">
        <div class="flex items-center gap-2">
            <div class="bg-indigo-600 p-2 rounded-lg text-white">
                <i data-lucide="wand-2"></i>
            </div>
            <h1 class="text-xl font-bold text-gray-800">Ù…Ø­Ø±Ø± Ø§Ù„ØµÙˆØ± (Ù†ØµÙˆØµ + Ø±Ø³Ù…)</h1>
        </div>
        
        <div class="flex gap-3 items-center">
            <!-- Toggle Original Image Preview -->
            <div id="toggleOriginalContainer" class="hidden flex items-center gap-2 bg-gray-100 p-1 rounded-lg mr-4">
                <span class="text-xs font-medium text-gray-500 px-2">Ø¹Ø±Ø¶ Ø§Ù„Ø£ØµÙ„ÙŠØ©:</span>
                <button id="toggleOriginalBtn" class="w-10 h-6 bg-gray-300 rounded-full p-1 relative transition-colors focus:outline-none">
                    <div id="toggleKnob" class="w-4 h-4 bg-white rounded-full shadow-sm transform transition-transform translate-x-0"></div>
                </button>
            </div>

            <button id="downloadBtn" disabled class="flex items-center gap-2 px-4 py-2 rounded-lg text-white transition bg-gray-300 cursor-not-allowed">
                <i data-lucide="download" width="18"></i>
                <span>ØªØµØ¯ÙŠØ±</span>
            </button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        
        <!-- Right Sidebar: Tools & Layers -->
        <aside class="w-80 bg-white border-l flex flex-col overflow-hidden shadow-sm z-10 relative">
            
            <!-- Upload Section -->
            <div class="p-5 border-b flex-shrink-0">
                <label class="flex flex-col items-center justify-center w-full h-20 border-2 border-dashed border-indigo-300 rounded-xl cursor-pointer bg-indigo-50 hover:bg-indigo-100 transition group">
                    <div class="flex flex-col items-center justify-center pt-2 pb-3">
                        <i data-lucide="upload" class="w-5 h-5 mb-1 text-indigo-500 group-hover:scale-110 transition"></i>
                        <p class="text-xs text-gray-500 font-medium">Ø±ÙØ¹ ØµÙˆØ±Ø©</p>
                    </div>
                    <input type="file" id="imageUpload" class="hidden" accept="image/*" />
                </label>
            </div>

            <!-- Controls Container -->
            <div id="controlsContainer" class="flex-1 overflow-y-auto p-5 space-y-6 opacity-50 pointer-events-none transition-opacity">
                
                <!-- Tools Toggle -->
                <div class="flex-shrink-0">
                    <label class="text-xs font-bold text-gray-400 uppercase mb-3 block">Ø§Ù„Ø£Ø¯ÙˆØ§Øª</label>
                    <div class="grid grid-cols-3 bg-gray-100 p-1 rounded-lg gap-1">
                        <button id="toolSelect" class="tool-btn flex flex-col items-center justify-center gap-1 py-2 rounded-md text-[10px] font-medium transition bg-white shadow text-indigo-600">
                            <i data-lucide="move" width="18"></i> ØªØ­Ø±ÙŠÙƒ
                        </button>
                        <button id="toolBox" class="tool-btn flex flex-col items-center justify-center gap-1 py-2 rounded-md text-[10px] font-medium transition text-gray-500 hover:bg-gray-200">
                            <i data-lucide="box-select" width="18"></i> Ù†Øµ / Ù†Ù‚Ø±
                        </button>
                        <button id="toolPen" class="tool-btn flex flex-col items-center justify-center gap-1 py-2 rounded-md text-[10px] font-medium transition text-gray-500 hover:bg-gray-200">
                            <i data-lucide="pen-tool" width="18"></i> Ù‚Ù„Ù…
                        </button>
                    </div>
                    <p class="text-[10px] text-gray-400 mt-1 text-center">Ù†ØµÙŠØ­Ø©: Ø§Ù†Ù‚Ø± Ø¨Ø§Ù„ØµÙˆØ±Ø© Ù„Ø¥Ø¶Ø§ÙØ© Ù†Øµ Ø³Ø±ÙŠØ¹</p>
                </div>

                <!-- Properties Panel (Dynamic based on selection) -->
                <div id="propertiesPanel" class="hidden space-y-4 flex-shrink-0 border p-3 rounded-lg bg-gray-50">
                    <div class="flex justify-between items-center border-b pb-2 mb-2">
                        <label class="text-xs font-bold text-indigo-600 uppercase" id="propTitle">Ø®ØµØ§Ø¦Øµ</label>
                    </div>

                    <!-- Text Properties (Only for Text Layer) -->
                    <div id="textPropsGroup" class="space-y-3 hidden">
                        <!-- Quick Stamps -->
                        <div class="grid grid-cols-4 gap-1 mb-2">
                            <button class="stamp-btn bg-white border hover:bg-green-50 text-green-600 rounded p-1 text-xs font-bold shadow-sm transition" data-text="âœ… ØµØ­">âœ… ØµØ­</button>
                            <button class="stamp-btn bg-white border hover:bg-red-50 text-red-600 rounded p-1 text-xs font-bold shadow-sm transition" data-text="âŒ Ø®Ø·Ø£">âŒ Ø®Ø·Ø£</button>
                            <button class="stamp-btn bg-white border hover:bg-blue-50 text-blue-600 rounded p-1 text-xs font-bold shadow-sm transition" data-text="â“ Ø³Ø¤Ø§Ù„">â“ Ø³Ø¤Ø§Ù„</button>
                            <button class="stamp-btn bg-white border hover:bg-gray-50 text-gray-600 rounded p-1 text-xs font-bold shadow-sm transition" data-text="ğŸ“ Ø¥Ø¬Ø§Ø¨Ø©">ğŸ“ Ø¥Ø¬Ø§Ø¨Ø©</button>
                        </div>

                        <div class="space-y-1">
                            <input type="text" id="propText" class="w-full p-2 border rounded-lg text-sm" placeholder="Ø§Ù„Ù†Øµ Ù‡Ù†Ø§...">
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <input type="number" id="propSize" class="w-full p-2 border rounded-lg text-sm" placeholder="Ø§Ù„Ø­Ø¬Ù…">
                            <select id="propFont" class="w-full p-2 border rounded-lg bg-white text-sm">
                                <option value="Cairo">Cairo</option>
                                <option value="Arial">Arial</option>
                                <option value="Tahoma">Tahoma</option>
                            </select>
                        </div>
                    </div>

                    <!-- Brush Properties (For Pen or Drawing Layer) -->
                    <div id="brushPropsGroup" class="space-y-3 hidden">
                        <div class="space-y-1">
                            <label class="text-xs text-gray-500 flex justify-between">
                                <span>Ø³Ù…Ùƒ Ø§Ù„Ø®Ø·</span>
                                <span id="brushSizeVal">5px</span>
                            </label>
                            <input type="range" id="propBrushSize" min="1" max="50" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>

                    <!-- Common Colors -->
                    <div class="space-y-1">
                        <div class="flex gap-2 items-center">
                            <!-- Main Color -->
                            <div class="flex-1 flex items-center gap-2 border p-2 rounded-lg bg-white" title="Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ">
                                <div class="w-4 h-4 rounded-full border" id="colorPreview"></div>
                                <input type="color" id="propColor" class="w-full h-6 rounded cursor-pointer border-0 p-0 bg-transparent opacity-0 absolute w-8">
                                <span class="text-xs text-gray-500 ml-6">Ø§Ù„Ù„ÙˆÙ†</span>
                            </div>
                            
                            <!-- BG Color (Text Only) -->
                            <div id="bgColorGroup" class="flex-1 flex items-center gap-2 border p-2 rounded-lg bg-white relative group hidden">
                                <div id="bgColorPreview" class="w-4 h-4 rounded border bg-gray-100 flex items-center justify-center text-[8px]">A</div>
                                <input type="color" id="propBgColor" class="absolute inset-0 opacity-0 cursor-pointer">
                                <span class="text-xs text-gray-500">Ø·Ù…Ø³</span>
                                <button id="autoBgBtn" class="absolute -top-2 -left-2 bg-indigo-600 text-white text-[9px] p-1 rounded-full opacity-0 group-hover:opacity-100 transition">Auto</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Layers List Section -->
                <div id="layersSection" class="flex-1 flex flex-col overflow-hidden pt-4 border-t">
                    <label class="text-xs font-bold text-gray-400 uppercase mb-3 flex-shrink-0">Ø·Ø¨Ù‚Ø§Øª Ø§Ù„ØªØ¹Ø¯ÙŠÙ„</label>
                    <div id="layersList" class="layers-list flex-1 overflow-y-auto space-y-2 pr-1">
                        <!-- Layers added dynamically -->
                        <div id="noLayersHint" class="text-center py-4 text-gray-400 text-sm italic">
                            Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ù„Ø¥Ø¶Ø§ÙØ© Ù†ØµÙˆØµ Ø£Ùˆ Ø±Ø³ÙˆÙ…Ø§Øª.
                        </div>
                    </div>
                </div>

            </div>
        </aside>

        <!-- Main Canvas Area -->
        <main class="flex-1 bg-gray-200 overflow-auto relative flex items-center justify-center p-8" id="mainArea">
            <div id="noImagePlaceholder" class="text-center text-gray-500 bg-white p-8 rounded-xl shadow-sm">
                <i data-lucide="image" class="w-20 h-20 mx-auto mb-4 text-indigo-200 block"></i>
                <p class="text-xl font-bold text-gray-700 mb-2">Ø§Ø¨Ø¯Ø£ Ø¨Ø±ÙØ¹ ØµÙˆØ±Ø©</p>
            </div>

            <div id="canvasWrapper" class="hidden relative shadow-2xl border-4 border-white bg-white cursor-crosshair" style="max-height: 90vh; max-width: 90vw;">
                <canvas id="canvas" class="block" style="max-height: 100%; max-width: 100%; object-fit: contain;"></canvas>
                <img id="originalImageOverlay" class="absolute inset-0 w-full h-full object-contain hidden pointer-events-none z-30" alt="Original Preview">
            </div>
        </main>

    </div>

    <!-- Template for Layer Item -->
    <template id="layerItemTemplate">
        <div class="layer-item flex items-center gap-2 p-2 rounded-lg bg-gray-50 border border-gray-200 hover:bg-gray-100 transition cursor-pointer group select-none">
            <button class="layer-visible-btn text-gray-400 hover:text-indigo-600 transition p-1">
                <i data-lucide="eye" width="14"></i>
            </button>
            <div class="layer-icon text-gray-400">
                <i data-lucide="type" width="14"></i>
            </div>
            <div class="layer-name flex-1 truncate text-xs font-medium text-gray-700">
                Layer Name
            </div>
            <button class="layer-delete-btn text-gray-300 hover:text-red-500 transition p-1 opacity-0 group-hover:opacity-100">
                <i data-lucide="trash-2" width="14"></i>
            </button>
        </div>
    </template>

    <script>
        // --- Global State ---
        let image = null;
        // layers array can hold:
        // 1. Text Box: { type: 'text', id, x, y, w, h, text, fontSize, color, bgColor, calculatedBg, fontFamily, visible }
        // 2. Drawing: { type: 'drawing', id, points: [{x,y}], color, size, visible }
        let layers = []; 
        let selectedId = null;
        let mode = 'select'; // 'select', 'box', 'pen'
        let showOriginal = false;

        // Interaction State
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let currentItem = null; // For temp drawing/box creation

        // DOM Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const uploadInput = document.getElementById('imageUpload');
        const downloadBtn = document.getElementById('downloadBtn');
        const controlsContainer = document.getElementById('controlsContainer');
        
        // Tools
        const tools = {
            select: document.getElementById('toolSelect'),
            box: document.getElementById('toolBox'),
            pen: document.getElementById('toolPen')
        };

        // Properties
        const propsPanel = document.getElementById('propertiesPanel');
        const inputs = {
            title: document.getElementById('propTitle'),
            textGroup: document.getElementById('textPropsGroup'),
            text: document.getElementById('propText'),
            size: document.getElementById('propSize'),
            font: document.getElementById('propFont'),
            brushGroup: document.getElementById('brushPropsGroup'),
            brushSize: document.getElementById('propBrushSize'),
            brushSizeVal: document.getElementById('brushSizeVal'),
            color: document.getElementById('propColor'),
            colorPreview: document.getElementById('colorPreview'),
            bgGroup: document.getElementById('bgColorGroup'),
            bgColor: document.getElementById('propBgColor'),
            bgColorPreview: document.getElementById('bgColorPreview'),
            autoBgBtn: document.getElementById('autoBgBtn')
        };

        // Initialize Lucide
        lucide.createIcons();

        // --- Logic ---

        uploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    image = img;
                    layers = [];
                    selectedId = null;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    document.getElementById('originalImageOverlay').src = img.src;
                    
                    document.getElementById('noImagePlaceholder').classList.add('hidden');
                    document.getElementById('canvasWrapper').classList.remove('hidden');
                    document.getElementById('toggleOriginalContainer').classList.remove('hidden');
                    controlsContainer.classList.remove('opacity-50', 'pointer-events-none');
                    downloadBtn.disabled = false;
                    downloadBtn.classList.remove('bg-gray-300', 'cursor-not-allowed');
                    downloadBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700');

                    setMode('box'); // Default to box mode
                    updateLayersList();
                    render();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            e.target.value = ''; 
        });

        // --- Tools Switcher ---
        function setMode(newMode) {
            mode = newMode;
            // Update UI
            Object.values(tools).forEach(btn => {
                btn.classList.remove('bg-white', 'shadow', 'text-indigo-600');
                btn.classList.add('text-gray-500', 'hover:bg-gray-200');
            });
            tools[newMode].classList.add('bg-white', 'shadow', 'text-indigo-600');
            tools[newMode].classList.remove('text-gray-500', 'hover:bg-gray-200');

            // Cursor
            if (mode === 'select') canvas.style.cursor = "default";
            else if (mode === 'pen') canvas.style.cursor = "crosshair"; 
            else canvas.style.cursor = "text"; // Changed to text cursor for box/click mode

            // Selection logic
            if (mode !== 'select') {
                selectedId = null;
                updatePropsPanel();
                render();
            } else {
                updatePropsPanel();
            }
        }

        Object.keys(tools).forEach(k => tools[k].addEventListener('click', () => setMode(k)));

        // --- Canvas Events ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (!image || showOriginal) return;
            const pos = getPos(e);
            isDragging = true;
            dragStart = pos;

            if (mode === 'select') {
                // Find top-most visible layer clicked
                const clicked = [...layers].reverse().find(l => {
                    if (!l.visible) return false;
                    if (l.type === 'text') {
                        return pos.x >= l.x && pos.x <= l.x + l.w && pos.y >= l.y && pos.y <= l.y + l.h;
                    }
                    if (l.type === 'drawing') {
                        return l.points.some(p => Math.abs(p.x - pos.x) < 10 && Math.abs(p.y - pos.y) < 10);
                    }
                    return false;
                });

                selectedId = clicked ? clicked.id : null;
                updatePropsPanel();
                updateLayersList();
                render();

            } else if (mode === 'box') {
                currentItem = { x: pos.x, y: pos.y, w: 0, h: 0 };
            } else if (mode === 'pen') {
                const startColor = inputs.color.value; 
                const newLayer = {
                    id: Date.now(),
                    type: 'drawing',
                    points: [{x: pos.x, y: pos.y}],
                    color: startColor,
                    size: parseInt(inputs.brushSize.value),
                    visible: true
                };
                layers.push(newLayer);
                selectedId = newLayer.id; 
                currentItem = newLayer; 
                render();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging || showOriginal) return;
            const pos = getPos(e);

            if (mode === 'select' && selectedId) {
                const layer = layers.find(l => l.id === selectedId);
                if (layer && layer.type === 'text') {
                    const dx = pos.x - dragStart.x;
                    const dy = pos.y - dragStart.y;
                    layer.x += dx;
                    layer.y += dy;
                    dragStart = pos;
                    render();
                }
            } else if (mode === 'box' && currentItem) {
                currentItem.w = pos.x - currentItem.x;
                currentItem.h = pos.y - currentItem.y;
                render();
            } else if (mode === 'pen' && currentItem) {
                currentItem.points.push({x: pos.x, y: pos.y});
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (mode === 'box' && currentItem) {
                // Check if it was just a click (very small drag)
                const isClick = Math.abs(currentItem.w) < 5 && Math.abs(currentItem.h) < 5;
                
                let x, y, w, h;

                if (isClick) {
                    // CLICK TO ADD MODE
                    w = 120; // Default width
                    h = 50;  // Default height
                    x = currentItem.x - w/2; // Center on click
                    y = currentItem.y - h/2;
                } else {
                    // DRAG MODE
                    x = currentItem.w < 0 ? currentItem.x + currentItem.w : currentItem.x;
                    y = currentItem.h < 0 ? currentItem.y + currentItem.h : currentItem.y;
                    w = Math.abs(currentItem.w);
                    h = Math.abs(currentItem.h);
                }

                // Only add if it's a click OR a decent sized box
                if (isClick || (w > 10 && h > 10)) {
                    const calculatedBg = getAverageBgColor(x, y, w, h);
                    const newLayer = {
                        id: Date.now(),
                        type: 'text',
                        x, y, w, h,
                        text: "Ù†Øµ Ø¬Ø¯ÙŠØ¯",
                        fontSize: Math.max(16, Math.floor(h * 0.6)),
                        color: "#000000",
                        bgColor: "auto",
                        calculatedBg: calculatedBg,
                        fontFamily: "Cairo",
                        visible: true
                    };
                    layers.push(newLayer);
                    selectedId = newLayer.id;
                    setMode('select'); // Auto switch back to select to allow editing text immediately
                }
            } else if (mode === 'pen') {
                updateLayersList(); 
                updatePropsPanel(); 
            }
            
            isDragging = false;
            currentItem = null;
            render();
        });

        // --- Rendering ---
        function render() {
            if (!canvas || !image) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(image, 0, 0);

            if (showOriginal) return;

            // Box creation preview
            if (mode === 'box' && currentItem) {
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                // If it's tiny (click), don't draw weird box
                if(Math.abs(currentItem.w) > 5 || Math.abs(currentItem.h) > 5) {
                    ctx.strokeRect(currentItem.x, currentItem.y, currentItem.w, currentItem.h);
                }
                ctx.setLineDash([]);
            }

            layers.forEach(l => {
                if (!l.visible) return;

                if (l.type === 'text') {
                    // 1. BG (Inpainting)
                    ctx.fillStyle = l.bgColor === 'auto' ? (l.calculatedBg || '#fff') : l.bgColor;
                    ctx.fillRect(l.x, l.y, l.w, l.h);
                    
                    // 2. Text
                    ctx.fillStyle = l.color;
                    ctx.font = `bold ${l.fontSize}px ${l.fontFamily}`;
                    ctx.textBaseline = 'middle';
                    ctx.textAlign = 'center';
                    
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(l.x, l.y, l.w, l.h);
                    ctx.clip();
                    ctx.fillText(l.text, l.x + l.w/2, l.y + l.h/2);
                    ctx.restore();

                    // 3. Selection
                    if (l.id === selectedId && mode === 'select') {
                        ctx.strokeStyle = '#4f46e5';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(l.x, l.y, l.w, l.h);
                    }
                } 
                else if (l.type === 'drawing') {
                    if (l.points.length < 2) return;
                    
                    ctx.strokeStyle = l.color;
                    ctx.lineWidth = l.size;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(l.points[0].x, l.points[0].y);
                    for (let i = 1; i < l.points.length; i++) {
                        ctx.lineTo(l.points[i].x, l.points[i].y);
                    }
                    ctx.stroke();

                    if (l.id === selectedId && mode === 'select') {
                        ctx.save();
                        ctx.strokeStyle = 'rgba(79, 70, 229, 0.3)'; 
                        ctx.lineWidth = l.size + 6;
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            });
        }

        // --- Properties Logic ---
        function updatePropsPanel() {
            const layer = layers.find(l => l.id === selectedId);
            if (!layer) {
                propsPanel.classList.add('hidden');
                return;
            }
            propsPanel.classList.remove('hidden');

            if (layer.type === 'text') {
                inputs.title.textContent = "Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù†Øµ";
                inputs.textGroup.classList.remove('hidden');
                inputs.bgGroup.classList.remove('hidden');
                inputs.brushGroup.classList.add('hidden');

                inputs.text.value = layer.text;
                inputs.size.value = layer.fontSize;
                inputs.font.value = layer.fontFamily;
                
                const isAuto = layer.bgColor === 'auto';
                inputs.bgColorPreview.textContent = isAuto ? 'A' : '';
                inputs.bgColorPreview.style.backgroundColor = isAuto ? layer.calculatedBg : layer.bgColor;
            } 
            else if (layer.type === 'drawing') {
                inputs.title.textContent = "Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø±Ø³Ù…";
                inputs.textGroup.classList.add('hidden');
                inputs.bgGroup.classList.add('hidden');
                inputs.brushGroup.classList.remove('hidden');

                inputs.brushSize.value = layer.size;
                inputs.brushSizeVal.textContent = layer.size + 'px';
            }

            inputs.color.value = layer.color;
            inputs.colorPreview.style.backgroundColor = layer.color;
        }

        // Property Change Listeners
        function updateLayer(key, val) {
            if (!selectedId) return;
            const layer = layers.find(l => l.id === selectedId);
            if (!layer) return;
            
            layer[key] = val;
            render();
            if (key === 'text') updateLayersList();
            if (key === 'color') inputs.colorPreview.style.backgroundColor = val;
            if (key === 'size') inputs.brushSizeVal.textContent = val + 'px';
            if (key === 'bgColor') updatePropsPanel();
        }

        inputs.text.addEventListener('input', e => updateLayer('text', e.target.value));
        inputs.size.addEventListener('input', e => updateLayer('fontSize', parseInt(e.target.value)));
        inputs.font.addEventListener('change', e => updateLayer('fontFamily', e.target.value));
        inputs.color.addEventListener('input', e => updateLayer('color', e.target.value));
        inputs.brushSize.addEventListener('input', e => updateLayer('size', parseInt(e.target.value)));
        
        inputs.bgColor.addEventListener('input', e => updateLayer('bgColor', e.target.value));
        inputs.autoBgBtn.addEventListener('click', () => {
            const l = layers.find(l => l.id === selectedId);
            if(l) {
                l.calculatedBg = getAverageBgColor(l.x, l.y, l.w, l.h); 
                updateLayer('bgColor', 'auto');
            }
        });

        // Stamp Buttons Logic
        document.querySelectorAll('.stamp-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const text = btn.getAttribute('data-text');
                const textInput = document.getElementById('propText');
                textInput.value = text;
                updateLayer('text', text);
                
                // Optional: adjust font color based on stamp type
                if(text.includes('âœ…')) updateLayer('color', '#16a34a'); // Green
                if(text.includes('âŒ')) updateLayer('color', '#dc2626'); // Red
            });
        });

        // --- Layers List ---
        const layersContainer = document.getElementById('layersList');
        const tmpl = document.getElementById('layerItemTemplate');

        function updateLayersList() {
            layersContainer.innerHTML = '';
            if (layers.length === 0) {
                document.getElementById('noLayersHint').classList.remove('hidden');
                return;
            }
            document.getElementById('noLayersHint').classList.add('hidden');

            [...layers].reverse().forEach(l => {
                const item = tmpl.content.cloneNode(true).firstElementChild;
                
                if (l.id === selectedId) {
                    item.classList.add('bg-indigo-50', 'border-indigo-200');
                    item.classList.remove('bg-gray-50', 'border-gray-200');
                }

                const icon = item.querySelector('.layer-icon i');
                const name = item.querySelector('.layer-name');
                if (l.type === 'text') {
                    icon.setAttribute('data-lucide', 'type');
                    name.textContent = l.text || 'Ù†Øµ ÙØ§Ø±Øº';
                } else {
                    icon.setAttribute('data-lucide', 'pen-tool');
                    name.textContent = `Ø±Ø³Ù… ÙŠØ¯ÙˆÙŠ (${l.color})`;
                }

                const visBtn = item.querySelector('.layer-visible-btn i');
                visBtn.setAttribute('data-lucide', l.visible ? 'eye' : 'eye-off');
                if(!l.visible) item.querySelector('.layer-visible-btn').classList.add('text-gray-300');

                item.querySelector('.layer-visible-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    l.visible = !l.visible;
                    render();
                    updateLayersList();
                });
                item.querySelector('.layer-delete-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    layers = layers.filter(x => x.id !== l.id);
                    if (selectedId === l.id) {
                        selectedId = null;
                        updatePropsPanel();
                    }
                    render();
                    updateLayersList();
                });
                item.addEventListener('click', () => {
                    selectedId = l.id;
                    setMode('select'); 
                    updatePropsPanel();
                    updateLayersList();
                    render();
                });

                layersContainer.appendChild(item);
            });
            lucide.createIcons();
        }

        // --- Utilities ---
        function getAverageBgColor(x, y, w, h) {
            try {
                // Sample slightly outside the click area if possible, or just the area itself
                const data = ctx.getImageData(Math.max(0, x-5), Math.max(0, y), 5, Math.max(1, h)).data;
                let r=0,g=0,b=0,c=0;
                for(let i=0; i<data.length; i+=4){ r+=data[i]; g+=data[i+1]; b+=data[i+2]; c++; }
                if(c===0) return '#ffffff';
                r=Math.floor(r/c); g=Math.floor(g/c); b=Math.floor(b/c);
                return `rgb(${r},${g},${b})`;
            } catch { return '#ffffff'; }
        }

        document.getElementById('toggleOriginalBtn').addEventListener('click', function() {
            showOriginal = !showOriginal;
            const knob = document.getElementById('toggleKnob');
            if (showOriginal) {
                this.classList.add('bg-indigo-500'); this.classList.remove('bg-gray-300');
                knob.classList.add('translate-x-4');
                document.getElementById('originalImageOverlay').classList.remove('hidden');
                canvas.style.pointerEvents = 'none';
            } else {
                this.classList.remove('bg-indigo-500'); this.classList.add('bg-gray-300');
                knob.classList.remove('translate-x-4');
                document.getElementById('originalImageOverlay').classList.add('hidden');
                canvas.style.pointerEvents = 'auto';
                render();
            }
        });

        downloadBtn.addEventListener('click', () => {
            if (!image) return;
            const prevSel = selectedId;
            selectedId = null;
            render();
            const link = document.createElement('a');
            link.download = 'smart-edit.png';
            link.href = canvas.toDataURL();
            link.click();
            selectedId = prevSel;
            render();
        });

    </script>
</body>
</html>